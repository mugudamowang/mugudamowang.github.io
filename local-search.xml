<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>js继承</title>
    <link href="/2022/03/22/js%E7%BB%A7%E6%89%BF/"/>
    <url>/2022/03/22/js%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="原型链与继承"><a href="#原型链与继承" class="headerlink" title="原型链与继承"></a>原型链与继承</h2><blockquote><p>es5没有类的机制, 可以通过构造函数来充当类. 构造函数的属性和变量可以被实例继承.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> Human = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, age</span>)</span>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">let</span> mugu = <span class="hljs-keyword">new</span> human();<br></code></pre></td></tr></table></figure><ul><li>构造函数的形式每次实例化都会创建新的变量name, age. </li><li>他们<strong>无法共享</strong>. 比如, 如果有个函数较sayFxxk(){}, 这个函数实际上是稳定的, 没有必要重复创建. 会造成系统资源的浪费</li></ul><blockquote><p>为此, 定义了<code>prototype</code>原型对象.  原型对象上的属性和方法都可以被共享.</p></blockquote><ul><li>js规定每个函数都有<code>prototype</code>属性, 指向一个对象. </li><li>对于构造函数来说, 该属性会成为实例对象的原型.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">Human.prototype.sayFxxk = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; alert(<span class="hljs-string">&quot;hi&quot;</span>); &#125;<br><span class="hljs-comment">//上述方法mugu实例中并没有sayFxxk(). 但通过原型查找找到了该属性, 是共享的.</span><br><span class="hljs-comment">//mugu实例如果自己重写了sayFxxk(). 则不会用原型上的sayFxxk().</span><br></code></pre></td></tr></table></figure><blockquote><p>原型链</p><ul><li>所有对象都有自己的原型对象, 一个对象也可以充当其他对象的原型</li><li>由于原型对象也是对象, 他也有自己的原型.</li><li>所以这种机制下就会形成一条链, 我们叫它为原型链.</li></ul></blockquote><ul><li>原型链的顶端, 即<code>Object</code>构造函数的prototype. 所有对象都继承了它, 其中的共享方法如<code>toString</code>. <code>valueOf</code>. 再往上就是<code>null</code>了,</li><li>也就是说, 当寻找一个属性的时候, js引擎会逐级往上, 直到找到或者到原型链顶端(遍历). 返回undefined.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-built_in">Object</span>.prototype) == <span class="hljs-literal">null</span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>由于js原型链的特点, 可以将一个对象设为原型即实现了继承, 缺点和优点一样明显, 如果是引用类型的值(比如一个数组), 修改的时候牵一发而动全身, 容易造成属性修改的混乱. 而且无法向超类传参.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>Son.prototype = <span class="hljs-keyword">new</span> Father();<br></code></pre></td></tr></table></figure><h2 id="经典继承-借用构造函数"><a href="#经典继承-借用构造函数" class="headerlink" title="经典继承(借用构造函数)"></a>经典继承(借用构造函数)</h2><blockquote><p>借用构造函数在基类中调用超类的构造方法.</p></blockquote><p>既然不能直接使用超类或者传参, 那么在基类中调用超类的构造函数实例化一个就好了.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params"></span>)</span>&#123;<br>Father.call(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//继承了Father,且向父类型传递参数</span><br>&#125;<br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> Son();<br>instance1.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-built_in">console</span>.log(instance1.colors);<span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> Son();<br><span class="hljs-built_in">console</span>.log(instance2.colors);<span class="hljs-comment">//&quot;red,blue,green&quot; 可见引用类型值是独立的</span><br><br><span class="hljs-comment">//来自juejin.com</span><br></code></pre></td></tr></table></figure><p>虽然解决了前面的问题, 但很明显, 又回到老路子:</p><ul><li>不能复用函数, 违背原型的初心.</li><li>超类的方法, 基类不能访问(相当于father构造函数在son的内层作用域).</li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote><p>用原型链实现原型方法的继承, 构造函数实现实例属性的继承.</p></blockquote><p>那岂不是原型链不行, 构造函数也不行, 反观之, 我们主要目的是想要复用函数的同时一部分属性是唯一的. 那么, 原型链能复用函数, 构造函数能保证实例属性的唯一性. 那么两者结合起来就可以了, 这就是组合继承.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Father(<span class="hljs-params">name</span>)</span>&#123;<br>this.name = name;<br>this.colors = <span class="hljs-literal">[&quot;<span class="hljs-identifier">red</span>&quot;,&quot;<span class="hljs-identifier">blue</span>&quot;,&quot;<span class="hljs-identifier">green</span>&quot;]</span>;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Father</span>.</span></span>prototype.sayName = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;<br>alert(this.name);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Son(<span class="hljs-params">name</span>,<span class="hljs-params">age</span>)</span>&#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Father</span>.</span></span>call(this,name);<span class="hljs-comment">//继承实例属性，第一次调用Father()</span><br>this.age = age;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Son</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Father()</span>;<span class="hljs-comment">//继承父类方法,第二次调用Father()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Son</span>.</span></span>prototype.sayAge = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;<br>alert(this.age);<br>&#125;<br>var instance1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Son(<span class="hljs-string">&quot;louis&quot;</span>,5)</span>;<br>instance1.colors.push(<span class="hljs-string">&quot;black&quot;</span>);<br>console.log(instance1.colors);<span class="hljs-comment">//&quot;red,blue,green,black&quot;</span><br>instance1.say<span class="hljs-constructor">Name()</span>;<span class="hljs-comment">//louis</span><br>instance1.say<span class="hljs-constructor">Age()</span>;<span class="hljs-comment">//5</span><br><br>var instance1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Son(<span class="hljs-string">&quot;zhai&quot;</span>,10)</span>;<br>console.log(instance1.colors);<span class="hljs-comment">//&quot;red,blue,green&quot;</span><br>instance1.say<span class="hljs-constructor">Name()</span>;<span class="hljs-comment">//zhai</span><br>instance1.say<span class="hljs-constructor">Age()</span>;<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><p>缺点是, 调用了两次超类构造方法, 导致实例中存在不必要的超类的实例对象中的所有属性。    </p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><blockquote><p>又叫原型式继承, 和原型链差不多, 它可以依据现有对象为原型, 生成新的对象</p></blockquote><p>优点就是不用自己声明一个构造函数去设置原型, 缺点和原型链一样.</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><blockquote><p>封装继承的过程到一个构造函数中, 这样实现了对某个对象继承, 又拥有自己的属性和方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>)</span>&#123;<br><span class="hljs-keyword">var</span> clone = object(original);<span class="hljs-comment">//通过调用object函数创建一个新对象</span><br>clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//以某种方式来增强这个对象</span><br>alert(<span class="hljs-string">&quot;hi&quot;</span>);<br>&#125;;<br><span class="hljs-keyword">return</span> clone;<span class="hljs-comment">//返回这个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>很明显, 每次调用都会返回一个新对象, 同样不能复用方法.</p><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><blockquote><p>在继承原型时，我们继承的不是超类的实例对象，而是原型对象是超类原型对象的一个实例对象，这样就解决了基类的原型对象中增添了不必要的超类的实例对象中的所有属性d的问题。</p></blockquote><p>我们不要多余的, 就要那个原型上的东西. 将这个过程封装下, 那么在组合继承里</p><ul><li>将要继承的超类构造函数, 换成超类的原型对象的构造函数. </li><li>同时, 构造函数是基类</li><li>最后将基类的原型指向构造好的prototype上.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">subClass,superClass</span>)</span>&#123;<br><span class="hljs-keyword">var</span> prototype = object(superClass.prototype);<span class="hljs-comment">//创建对象</span><br>prototype.constructor = subClass;<span class="hljs-comment">//增强对象</span><br>subClass.prototype = prototype;<span class="hljs-comment">//指定对象</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化</title>
    <link href="/2022/03/21/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/03/21/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="什么是性能优化"><a href="#什么是性能优化" class="headerlink" title="什么是性能优化"></a>什么是性能优化</h3><p>性能优化简单点说就是提高网站访问速度, 网站稳定性和交互体验.</p><p>具体的可以在以下几个方面衡量:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-number">1</span>.减少整体资源的加载时间.<br><span class="hljs-number">2</span>.加快首屏渲染<br><span class="hljs-number">3</span>.平滑交互和动画效果<br><span class="hljs-number">4</span>.感知表现加强<br><span class="hljs-number">5</span>.性能的测定<br></code></pre></td></tr></table></figure><h3 id="性能优化指标"><a href="#性能优化指标" class="headerlink" title="性能优化指标"></a>性能优化指标</h3><blockquote><p>各种指标的加载时间基本在1~5秒内都是较好的.</p></blockquote><ol><li>RAIL模型 <a href="https://web.dev/rail/">使用 RAIL 模型衡量性能 (web.dev)</a></li><li>基于用户体验(前两个重要)<ol><li>FCP: first-content-paint, 白屏时间    <a href="https://web.dev/fcp/">First Contentful Paint 首次内容绘制 (FCP) (web.dev)</a></li><li>LCP: largest-content-paint, 最大内容区域绘制时间 <a href="https://web.dev/lcp/">Largest Contentful Paint 最大内容绘制 (LCP)</a></li><li>FID(&lt;300ms): first-input-delay, 首次输入延迟(js主线程忙, 不能响应操作, 如网页加载) <a href="https://web.dev/fid/">First Input Delay 首次输入延迟 (FID) (web.dev)</a></li><li>TTI: time-to-interact, 完全可交互时间(最后一个长任务结束后5s内主线程空闲)</li><li>TBT(&lt;600ms): total-block-time, 总阻塞时间</li><li>CLS(&lt;0.25ms最好不抖动): cumulative-layout-shift, 布局抖动</li></ol></li><li>web-vital: LCP+FID+CLS. 简化版</li></ol><h3 id="性能优化测试工具"><a href="#性能优化测试工具" class="headerlink" title="性能优化测试工具"></a>性能优化测试工具</h3><ol><li><p><strong>lighthouse</strong>: google开源的性能测试工具, 生成性能测试报告. 直接在chrome里面直接使用. 以本人网站bunkun.top为例子:</p><ol><li>性能表现:</li></ol><p><img src="https://s2.loli.net/2022/02/26/k1yXmf3N7UqCPct.png" alt="image-20220226173303832"></p><ol start="2"><li>优化建议</li></ol><p><img src="https://s2.loli.net/2022/03/21/t6PlJMi9EyY2RdX.png" alt="image-20220226174250329"></p><p>​    其他: 预加载所要请求的多源(图片). 降低服务器响应时间. 调整图片大小. 移除未使用的资源(js/css)</p><ol start="3"><li><p>诊断结果</p><p>多角度对得出的数据进行网站性能分析. 如静态资源的缓存策略. 降低js脚本执行时间, 文件压缩(影响分数很大)等</p></li><li><p>通过项: 符合要求的项.</p></li></ol></li><li><p><strong>Chrome devtools</strong></p><ol><li>network面板<ol><li>有无缓存测试</li><li>网路吞吐测试</li><li>coverage: 监控网站代码运行覆盖率. 如果一个大文件代码执行率低, 那可能存在一些无用代码可以优化. 因此可以用这个可视化结果对文件进行拆分以减少文件大小从而减小FCP等指标.</li></ol></li><li>memory面板<ol><li>内存泄漏测试</li></ol></li><li>performance面板<ol><li>运行时性能测试: 测试动画流畅度, 交互效果</li></ol></li></ol></li><li><p>webpagetest: 专业网站测试工具.</p></li></ol><h3 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="web的性能优化思路"><a href="#web的性能优化思路" class="headerlink" title="web的性能优化思路"></a>web的性能优化思路</h4><ol><li>分析网站: 利用分析工具(如lighthouse生成报告)分析性能瓶颈, 从报告建议和问题入手 ; 从前端页面生命周期入手.</li><li>提高加载速度: 主要针对FCP, LCP等优化, 检查文件压缩, 静态资源配置, 有无未使用资源等, 提高整体资源的加载速度直到符合要求.</li><li>完善交互体验: 主要网站交互体验, 降低FID, TTI等时间, 优化动画效果, 预加载动画, 骨架屏等提高用户感知.</li></ol><h4 id="图片类型选择"><a href="#图片类型选择" class="headerlink" title="图片类型选择"></a>图片类型选择</h4><p>图片的类型主要有位图和矢量图</p><ul><li>位图: 以像素为单位的, 像素点的平面排布图.</li><li>矢量图: 记录元素的形状和绘制算法, 以矢量的形式绘制线面. 因此放大不会失真.</li></ul><p>图片的压缩类型则包括</p><ul><li>无压缩: BMP</li><li>有损压缩: jpg/jepg</li><li>无损压缩: png, gif</li></ul><table><thead><tr><th>类型</th><th>说明</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>GIF</td><td>8bit压缩256色彩; 适用色彩较少的图片.</td><td>支持动画/透明/体积较小</td><td>色彩少</td></tr><tr><td>JPEG/JPG</td><td>在照片的使用比较频繁的有损压缩图片格式</td><td>体积小/24位色彩/渐进式加载</td><td>不透明/有损</td></tr><tr><td>PNG</td><td>支持多种位深的格式, 适合网页各种图片</td><td>无损/透明, 半透明/色彩多</td><td>不支持动画/压缩量相对较小</td></tr><tr><td>WEBP</td><td>谷歌出品, 兼具jpg和png的特点</td><td>体积小/透明</td><td>支持差</td></tr><tr><td>SVG</td><td>使用XML定义语言</td><td>不失真/体积很小</td><td>渲染成本</td></tr></tbody></table><p><a href="https://jayzangwill.github.io/blog/2020/04/07/img-knowledge/">前端该如何选择图片的格式</a></p><h4 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3. 最佳实践"></a>3. 最佳实践</h4><ul><li>性能评级工具（PageSpeed 或 YSlow）</li><li>合理设置 HTTP 缓存：Expires 与 Cache-control</li><li>静态资源打包，开启 Gzip 压缩（节省响应流量）</li><li>CSS3 模拟图像，图标base64（降低请求数）</li><li>模块延迟(defer)加载/异步(async)加载</li><li>Cookie 隔离（节省请求流量）</li><li>localStorage（本地存储）</li><li>使用 CDN 加速（访问最近服务器）</li><li>启用 HTTP/2（多路复用，并行加载）</li><li>前端自动化（gulp/webpack）</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAMstack构建-Hexo+Netlify</title>
    <link href="/2021/04/01/JAMstack%E6%9E%84%E5%BB%BA/"/>
    <url>/2021/04/01/JAMstack%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>转载注明作者和出处, peace~</p><h2 id="首先-什么是-JAMstack"><a href="#首先-什么是-JAMstack" class="headerlink" title="首先, 什么是 JAMstack ?"></a>首先, 什么是 JAMstack ?</h2><p><strong>JAMstack就是 javascript + apis + makeup</strong></p><p>其中js处理动态显示的部分; APIS则是一些可重用的API, 比如一些云函数和第三方服务; Makeup就是用来生成站点的模板了.  近年在国外发展势头迅猛.</p><p><strong>一句话就是增强版的静态网站</strong>.</p><p><strong>基本理念</strong>就是提供更加简便迅速的开发体验; 因为这种模式以<strong>更低的成本, 更高的性能和更好的伸缩性</strong>让jamstack在网站构建方案中脱颖而出.</p><blockquote><ul><li>更好性能: 通过CDN分发静态资源等内容</li><li>更加安全: 没有传统的web服务器, 不需要担心常见的网络攻击</li><li>更方便: 直接托管在相应的服务中, 而且很便宜甚至免费, 比如githubpage/netlify, 国内的有gitee和腾讯云等都有相关服务</li><li>更加分离: 不需要限制在传统的开发体系中, 做到敏捷开发部署, 实时预览</li><li>更有伸缩性: 依托在CDN网络上, 网络性能伸缩性很好, 不需要担心传统服务器性能受限等问题.</li></ul></blockquote><p><strong>使用技巧</strong></p><blockquote><ul><li>CDN</li><li>原子发布: 每一次发布都是一次独立版本</li><li>无效缓存, 一旦重新发布, CDN就会更新原来的资源</li><li>通过版本系统控制, 如git, 轻易追踪文件地改动</li><li>自动构建: 当网站发布时, 通过webhook通知sever进行构建, server会构建项目并且更新CDN</li></ul></blockquote><p><strong>常见的构建方式</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 先本地开发, 现在一般通过静态站点生成器SSG如Hexo, Hugo, Getsby,Next等去生成静态资源. 我用的Hexo是使用Markdown文档作为模板输入而生成静态网页资源.<br><br><span class="hljs-bullet">2.</span> 版本控制系统如git进行管理, 一般这些SSG都会有相应的集成, 发布到远程仓库如github<br><br><span class="hljs-bullet">3.</span> 之后可以托管这些静态资源到相应的服务提供商上, 由他们曲部署构建和更新CDN, 常见有githubPage, Netlify, 国内的话可以用giteePage或者腾讯云的托管.<br><br></code></pre></td></tr></table></figure><p>当然上面这些提到的都是静态资源的部分, 那么如果有一些动态更新的地方, 就可以通过第三方API和云函数实现动态调用.</p><p><strong>一般有</strong></p><blockquote><ul><li>云开发: 添加自定义的云函数, 如腾讯云开发/netlify funciton/AWS; 可以添加云数据库来存储用户数据等.</li><li>评论: 有很多相关的评论服务可以使用, 如valine/twikoo/gittalk等. 一般一些JAMstack产品都会提供</li><li>其他: 搜索服务/表单服务/统计脚本/电子商务.</li></ul></blockquote><p>此外还有一种究极省事的方式, 就是通过CMS去完成内容管理和自动部署, 这种被叫做无头CMS, 如语雀/notion一类的内容管理平台.</p><p>这种CMS 系统<strong>会对外提供 API</strong>，网站生成器可以调用这些 API 拉取数据，<strong>将动态数据渲染成为静态页面</strong></p><p>这样内容创作者只需要专注于内容而不需要花费大量精力在web构建上.</p><p><strong>相比较传统类型构建方案</strong></p><table><thead><tr><th>类型</th><th>JAMstack的优势</th></tr></thead><tbody><tr><td>纯静态</td><td>JAMstack在纯静态上做了动态处理和内容管理上的增强, 所以相比纯静态, 交互性和管理体验更好</td></tr><tr><td>传统前端-后台服务器模式</td><td>在安全性/速度/可伸缩性上无可比拟. 传统的模式需要一个在线的服务器实时渲染和提供页面数据, 对于突变的请求量则很难控制, 而且扩容迁移都比较麻烦. JAMstack使用CDN分发静态页面, 这是太最大的优势</td></tr><tr><td>SPA</td><td>SPA的强大有目共睹, 当时缺点也很明显, 那就是SEO不友好, 即使现状有所改善, 但也无法避免性能问题.</td></tr></tbody></table><p><strong>JAMstack适用场景</strong> </p><blockquote><ul><li>大量静态内容</li><li>如wiki, 博客网站, 文档, 电商网站, 企业官网等</li></ul></blockquote><p><strong>不适用</strong></p><blockquote><ul><li>大量动态更新内容</li><li>如聊天室\视频直播\论坛等.</li></ul></blockquote><h2 id="本博客的JAMstack构建方案"><a href="#本博客的JAMstack构建方案" class="headerlink" title="本博客的JAMstack构建方案"></a>本博客的JAMstack构建方案</h2><p>博主经历了<code>githupage--&gt;giteePage--&gt;Netfily</code>的艰辛构建史. </p><p>期间升级了一次<code>Hexo3.2.0--&gt;Hexo5.4.0</code>, </p><p>以及主题版本<code>Fluid--&gt;1.89</code>. </p><p><strong>本方案适合几乎无费用/访问量一般的阶段使用, 全部<s>白嫖</s> XD</strong></p><p>目前使用的构建方案是:</p><blockquote><ol><li>SSG框架:  Hexo5.4.0</li><li>版本控制: git, github</li><li>免费托管服务: Netlify</li><li>免费第三方API和公共CDN:  jsdelivr , Leancloud</li></ol></blockquote><p>使用Hexo主题<code>Fluid</code>中集成了一些<code>Jsdelivr</code>的公共CDN, 并提供了<code>Leancloud</code>的评论接口, 非常nice!  </p><p>因为是博客网站, 所以需要的动态服务不多, 最主要的是评论和访问统计, 这一块的配置方案建议使用<strong>基于Leancloud的Valine评论系统, PV统计建议使用不蒜子, 特别省心</strong>. 而且同第三方库可以是实现邮件通知等功能. </p><p>所以第一步就是去Hexo文档去<strong>构建部署自己的站点</strong>, 之后选择Fluid或者其他<strong>主题进行配置</strong>.</p><p><a href="https://hexo.io/zh-cn/">1. Hexo</a></p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">2. hexo 主题: Fluid</a></p><p><a href="https://valine.js.org/">3. valine无后端评论系统</a></p><p><a href="https://busuanzi.ibruce.info/">4. 不蒜子极简统计</a></p><p>PS: 截至目前博客访问量🎉🎉</p><p><img src="https://i.loli.net/2021/04/01/tZmDjQFWClocUOX.png" alt="image-20210401135558131"></p><p>托管服务使用Netlify, 太香了~. <strong>之前使用的是githubPage托管, 图个省心, 奈何首屏要11s</strong>, 简直是上古时代的速度😂, 果断放弃. 之后尝试了giteePage的托管, 效果和Netlify差不多, 前面一个是Gitee后面一个是Netfily:</p><p><img src="https://i.loli.net/2021/04/01/76AhUdHOwXxt4fo.png" alt="image-20210401132713843"></p><p><img src="C:\Users\Mr.yang\AppData\Roaming\Typora\typora-user-images\image-20210401132634558.png" alt="image-20210401132634558"></p><p>相比下giteePage速度更快一些, 毕竟是国内托管服务. 但是最蛋疼的是, <strong>它要<code>PRO</code>才能自定义域名</strong>, <s>不能白嫖</s>, 这不符合我geek的精神. 如果不介意的话giteePage倒是不错的选择. </p><p><img src="https://i.loli.net/2021/04/01/NOpAiwlzhFLJH42.png" alt="image-20210401133128209">❌</p><p><img src="https://i.loli.net/2021/04/01/sXicz4ykYEKT2ab.png" alt="image-20210401133154722">✔</p><p>到阿里云等买一个域名(这个12块钱一年🤣), <strong>Netlify和githubPag而都支持自定义域名绑定</strong>, 只要到相应的提供商哪里解析一下DNS即可.</p><p><a href="https://wanwang.aliyun.com/domain/">阿里云域名注册</a></p><p>不过有个坑🕳, 就是使用了不带www的二级域名<strong>会让Leancloud的PV和UV计数失效. 而且邮件提醒功能也无法进行</strong>, 非常蛋疼. 当然这是白嫖下的妥协, 如果不想要www, 可以通过氪金解决.</p><p><a href="https://valine.js.org/notify.html">设置valine邮件提醒</a></p><p><strong>而且, 选择Netfily可以直接监管github仓库的更新</strong>, 这样Hexo + github + Netlify + Leancloud的一条龙方案特别nice~.</p><p>当然也可以尝试使用其他托管服务, 这里仅仅是博主个人使用过的做分享.</p><p><a href="https://netlify.com/">Netlify</a></p><p><a href="https://gitee.com/help/articles/4136">giteePage</a></p><p><a href="https://sspai.com/post/54608">githubPage</a></p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>大体上针对JAMstack的优化是CDN服务的优化和文件压缩. 而且也有很多现成插件可以在构建前打包, 非常便捷! 经过测试, 优化之后加载速度快了近一倍~.</p><p>以下是最新版本Fluid的优化方案: </p><ul><li><p>压缩图片</p><ul><li>可以使用Fluid中内置的压缩功能</li><li>使用hexo-all-minifier</li><li>使用TinyPing等第三方压缩之后再上传.</li></ul></li><li><p>压缩生成文件</p><p>通过hexo-all-minifier压缩生成的前端静态文件和图片</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-all-minifier<br><br><span class="hljs-comment">### 在博客_config.yml中设置</span><br>all-minifier: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>其中自定义启动concator:</p><ul><li>js_concator将生成的js合并, 打包成一个脚本文件并放在页面末尾, 以此减少请求数量和避免阻塞</li><li>bug: 使用js_concator打包之侯会让评论插件不可用, 可能是APIs与其冲突了.</li></ul></li><li><p>使用 CDN服务</p><p>hexo-fluid默认使用了jsDelivr服务, 将常用的第三方库配置公共 CDN </p><ul><li>也可以使用staticfile\bootcdn等</li><li>可以购买私有CDN进行加速, <a href="https://www.julydate.com/post/60859300">cdn</a></li></ul></li></ul><p>以前弄过WordPress那一套, 太憋屈, 老是要安装各种插件, 一个贫民服务器还经常搞崩, 没钱购买安全防护就得承受到web攻击, 速度还一般.  通过简单的配置和加载优化就可以使用上和以前要花费大价钱配置的网站同样的体验, 美哉美哉.</p><p><strong>所以对于博客网站来说, JAMstack YES!</strong></p><h2 id="核心概念-CDN"><a href="#核心概念-CDN" class="headerlink" title="核心概念-CDN"></a>核心概念-CDN</h2><p>内容交付网络（CDN）是指一组在地理上分散的服务器，它们协同工作以提供互联网内容的快速交付。</p><p>CDN允许快速转移加载互联网内容所需的资产，包括HTML页面、javascript 文件、样式表、图像和视频。 CDN服务的受欢迎程度持续增长。如今，大多数网页流量都通过CDN提供服务，包括来自Facebook、奈飞和亚马逊等主要网站的流量。</p><p><a href="https://www.cloudflare.com/zh-cn/learning/cdn/what-is-a-cdn/">more</a> </p>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>JAMstack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端二向箔-HTML</title>
    <link href="/2021/03/15/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HTML/"/>
    <url>/2021/03/15/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HTML/</url>
    
    <content type="html"><![CDATA[<h2 id="绪论-系统化前端知识复盘"><a href="#绪论-系统化前端知识复盘" class="headerlink" title="绪论 系统化前端知识复盘"></a>绪论 系统化前端知识复盘</h2><h3 id="我的疑惑"><a href="#我的疑惑" class="headerlink" title="我的疑惑"></a>我的疑惑</h3><p>本人接触编程到学习前端知识, 估摸已有近一年多时间, 在这个过程中遇到了一些常见的问题:</p><ul><li>知识碎片化, 即使学习了大量的知识, 也有进行一些实战操作, 但很多时候知识系统一片混乱</li><li>即使使用了一些管理工具, 如onenote\博客\notion等, 仍然觉得自身整理的内容缺乏条理和价值</li><li>难以坚持, 在进行了约3-4个月的博客记录后, 之后频率降低, 有学习抵触心理</li><li>前景的思考, 前端的价值何在, 如何提升自身核心竞争力, 以及职业生涯成长规划如何. 相比之下, 后端较多情况下就是业务核心, 而前端大多是附属增值手段.</li></ul><h3 id="思考原因"><a href="#思考原因" class="headerlink" title="思考原因"></a>思考原因</h3><p>很多问题无法回避, 这里面主要是入门后的迷茫感和价值取向. 众口纷云的”35岁危机”绝不是空穴来风. 这种双重的疑问很容易造成对自身学习能力和目的的怀疑. 我是否真的适合这行当? 我是否真该选择做前端?</p><p>很大程度上几个疑惑是相互关联的, 主要是因为反馈结果不良, 造成热情低能状态, 进而没有很好地组织知识框架. 或者组织了知识框架, 缺乏规律性\科学的复盘计划, 也会得不偿失. 这有许多原因, 如个人网站曝光不够\自身文章质量不佳\缺乏自己的提炼思考, 为了记录而记录.</p><h3 id="前端价值何在"><a href="#前端价值何在" class="headerlink" title="前端价值何在?"></a>前端价值何在?</h3><p>本文不是吹毛求疵, 更不是贬低前端价值.</p><p>确实, 在我所认知的编程行业中, 前端即使脱离的<strong>机械性\大量</strong>的基础操作, 近年来也有优秀的<strong>工程化项目</strong>发展壮大, 但似乎许多东西还是拿来做着以前一样的事情, 只不过是换了种方式表达. 那似乎前端无法摆脱自身的枷锁, <strong>向更高价值区间跃进</strong>. 特别是在分工明确的团队中, 美工\UI将用户体验基本完成, 而前端的价值似乎又被瓜分, 在其中只做一个效率中间件. 而不管在大厂还是小厂, 这种局面似乎普遍存在, 望求解. </p><p>这种想法一定程度上受限于我个人的知识和经验, 前端发展势不可挡, 而且它还很年轻, 潜力还有许多可以发掘, 但这些质疑也应当被每个学习前端的深思过. 前端的价值何在? <strong>个人所见, 于商业上, 高效\多端可靠\用户交互做到完美符合用户需求; 于技术上, 改变信息的传播, 以极具创造力的方式来为生活\生产带来质的变化</strong>. 前端首先是个工程师, 然后是个前端, 说到底, 对于俗人来说, 这全都是谋生的手段. 放大来讲, 更不应该局限于前端这个标签, 应去了解学习编程世界的全貌, 纵横捭阖才观得大势. 要向着高层框架的角度去思考前端移动展示和用户交互而前进, 而非做个<strong>思想的螺丝钉</strong>, 一心一意切页面.</p><h3 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h3><p>选择在博客平台进行表达, 进行复盘, 精进与勉励. 计划在1~2个月内完成前端复盘工作, 说是复盘, 更多的是自我检查和自省. </p><p>复盘主要解决的是知识点由散乱到连线成面的过程. 做好自身的管理, 协调时间提升自己, 形成系统化的前端知识体系, 建立学习的方法论. 不在被动式地焦虑疑惑. </p><p>复盘也将更多的在每一门技术的价值\背景\设计思想的角度出发. 而不是简单的用法记录, 那样无异于无意义学习. (而且还灌水)</p><p>诸君共勉.</p><h2 id="01-学习路线RoadMap"><a href="#01-学习路线RoadMap" class="headerlink" title="01 学习路线RoadMap"></a>01 学习路线RoadMap</h2><p><a href="https://juejin.cn/post/6924858439587889165">00 绪论 系统化前端知识复盘</a></p><h3 id="我学前端的核心思想"><a href="#我学前端的核心思想" class="headerlink" title="我学前端的核心思想"></a>我学前端的核心思想</h3><p>大多数大学是不会将前后端之类具体职业设立为专业的, 即使开设有前端相关课程, 较多都是以jsp和一些接近过时的网页开发知识. 原因有二: <strong>①高校培养人才目的不是为了岗位培养</strong>, 而是为了综合性的指标, 个人成长, 社会价值和行业发展. <strong>②前端变化太快了</strong>, 大学老师旨在授课于知识的方法论和处世之道, 而非培训班, 更与教学育人的属性有出入. </p><p>即使如此, 有个很矛盾的地方, 就是前端的顶尖人才匮乏, 这个职业很年轻, 潜力无限, 需要有着高水平和创新力的人才. 奈何于大学专业授课的属性相悖, <strong>导致没有系统的教学方案</strong>人才培养计划, 大多数都是依靠自学, 或者培训班. 缺乏系统的知识体系就难以维系大量的知识积累和实践. 结果就会出现前端过热, 却仍然没有多大突破性的发展.</p><p>所以, 要立志高远, 格物致知. 不要陷入重复性\无意义劳动的陷阱, 这样只会固步自封. <strong>保持持续学习的能力</strong>是任何一个人在行业中精进的核心. 也不要局限于岗位之上, 吃饭固然重要, 如何利用自身资源和优势, 去实现更高的目标, 而非办公室一隅孤芳自赏. </p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>建立系统的前端知识结构体系, 锻炼工程师素养</li><li>完善学习编程的方法论</li><li>技术的核心思想的理解</li><li>学习交流, 自检</li></ul><h3 id="组织形式"><a href="#组织形式" class="headerlink" title="组织形式"></a>组织形式</h3><p>常见网络知识博客组织形式都是以某个技术热点为展开, 这样有个弊端, 较难从语言\数据结构\性能架构的层次去理解知识. 而且缺乏相关的逻辑关联, 导致即使学了很多, 也看懂了, 间歇性地遗忘地问题, 显然这种形式对构建知识体系并不友好.</p><p>web前端核心就是Javascript语言, 对于语言, 可以以语言地学习规律去串联各个技术点. 特别是Javascript, 可以从<strong>语言的结构, 运行环境和执行</strong>三部分去组织, 向下引伸可以是基础语法\内存\数据结构-堆, 栈\事件等. </p><p>对于一些<strong>html</strong>和<strong>css</strong>, 此类标记语言和样式语言, 组织形式尤为重要. html要考察其<strong>合理性\语义化\分类归纳</strong>, css一方面是美学素养, 对于前端工程师, 更重要的是<strong>高性能的架构</strong>, 可靠的兼容性\交互效果, 所以要着重理解其设计模式. </p><p>之后是一些常见API和计算机网络知识, 这一部分主要是考察应用和理解. 其中, 浏览器模型需要了解其实现原理, 并与API, 网络技术相互关联, 深化架构体系</p><p>最后才是一些关键技术问题和热点, 如前端工程化, 前端框架探讨, 以及面试问题的收录.</p><h3 id="RoadMap-来自github"><a href="#RoadMap-来自github" class="headerlink" title="RoadMap-来自github"></a>RoadMap-来自github</h3><ul><li>一份来之gayhub的高星前端技术路线 <a href="https://github.com/kamranahmedse/developer-roadmap">link↗</a></li><li>查看我的notion整理页面: <a href="https://www.notion.so/Web-developer-in-2020-446c2641a2a44cf5894832bda363e364">link↗</a></li><li>可能有更新, 可以上GitHub查看最新版</li><li>可以作为参考, 进行遍历学习或者复盘, 当然要结合我之前的组织形式进行构建体系, 这些远远不够, 需要更加主动地收集知识管理的方法论\模型, 整理出自己的架构.</li><li>一边写一边尝试知识的组织信息</li></ul><p><img src="https://i.loli.net/2021/02/12/bezEol7fgCnGYyj.png" alt="road"></p><h2 id="02-HTML语义化"><a href="#02-HTML语义化" class="headerlink" title="02 HTML语义化"></a>02 HTML语义化</h2><p>语义化标签应该是HTML5基本的规范要求, 对于良好的web语义化, 不单是说表义上理解的标签语义, 语义化最大的好处是<strong>方便机器识别</strong>. 特别是在一些<strong>视障人群</strong>和<strong>阅读模式</strong>的适配. 良好的语义化更有利于网页<strong>SEO</strong>, 增加曝光. </p><p>这些应该是初级入门时了解到的语义化的相关程度. 而对于深入一些, 应该对于语义化有业务场景结合的思考.</p><p>当然, 个人认为, 要真正理解并运用语义化, 还要对<strong>HTML内容分类</strong>有较深入了解, MDN已有优质<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories">wiki🔗</a></p><h3 id="不求一丝不苟-只需因地制宜"><a href="#不求一丝不苟-只需因地制宜" class="headerlink" title="不求一丝不苟, 只需因地制宜"></a>不求一丝不苟, 只需因地制宜</h3><p>刚开始入门的时候, 语义化的实施要么一丝不苟地严格使用, 要么零散分布, 想起来的时候就用上. 但一段时间后大多不会在语义上有太多讲究, 用的最多地就是<code>header</code> <code>section</code> <code>nav</code> 等常见标签. </p><p>事实上, 花费时间过渡琢磨和不讲究都不是语义化的良好实践. 在应用层面上, 也许**<code>div</code>和<code>span</code>加上class完全可以完成业务需求**, 而且对于性能表现也不会有太大影响. 语义化更多的用处是在<strong>wiki页面</strong>上, 这类网页有良好的阅读目的, 因此语义化较为重要.</p><p>反而错误使用语义化标签会导致负面影响, 如常见的, <code>ul</code> <code>ol</code>, 前者表并列, 后者表顺位. 还有用<strong>div和span去交错包裹形成混乱的嵌套</strong>, 对浏览器阅读识别很不友好.</p><p>因此, 对于语义的使用, 是需要确保可以合理的组织运用, <strong>保持语义化结构不被平铺的div和span打断.</strong></p><p>接下来分析一下如何实践语义化规范.</p><h3 id="基于wiki类型的语义化例子"><a href="#基于wiki类型的语义化例子" class="headerlink" title="基于wiki类型的语义化例子"></a>基于wiki类型的语义化例子</h3><p>此类网页语义化内容并不多, 无非是围绕<strong>文章内容呈现</strong>而定制地几个标签结构.<br>一个典型地wiki详情页的<code>body</code>应该有以下结构, 常用于博客, 新闻界面类型的网页应用.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来以<a href="https://developer.mozilla.org/zh-CN/docs/Learn">MDN↗</a>为例, 结合上述Sample, 对于语义化进行阐述.</p><p><img src="https://i.loli.net/2021/02/11/c1LEJjhxzI6GCPZ.png" alt="image-20210211232520414"></p><p>👆非实际页面结构, 辅助理解</p><h3 id="如何优雅地使用"><a href="#如何优雅地使用" class="headerlink" title="如何优雅地使用"></a>如何优雅地使用</h3><p>整体可以拆分为结构元素和内嵌元素, wiki页面追求SEO, 传播目的性强, 需要组织成良好的语义化网页.</p><h4 id="1-结构元素"><a href="#1-结构元素" class="headerlink" title="1. 结构元素"></a>1. 结构元素</h4><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>网页头部, 展示介绍性的内容, 辅助工具等, 也常用于包裹标题组合.</p><p><img src="https://i.loli.net/2021/02/11/HebvGRTuWPFB2Cw.png" alt="image-20210211230200731"></p><h4 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h4><p>侧边栏, 工具类, 导航, 于页面内容独立且不影响主体</p><p><img src="https://i.loli.net/2021/02/11/l4LHI7TdXBPJkuE.png" alt="image-20210211233102497"></p><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>main表示的内容要求独立性, 且具有分段意义, 因此, 对于网页上独立的内容需要用main概括.</p><h4 id="article"><a href="#article" class="headerlink" title="article"></a>article</h4><p>article相比main强调的是媒体内容, 特别是新闻传播中有独立意义的文章.</p><p><img src="https://i.loli.net/2021/02/11/BxRNUTnoqAwrZtk.png" alt="image-20210211234457735"></p><h4 id="section"><a href="#section" class="headerlink" title="section"></a>section</h4><p>section并没用较明确的语义, 一般就作组成部分. 可以用作</p><ul><li>文档大纲概要, 一般包括一个标题和文字描述</li><li>文章内容分段</li></ul><p><img src="https://i.loli.net/2021/02/12/EuMIFTP8vg7VpJn.png" alt="image-20210212121628861"></p><h4 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h4><p><code>footer</code>分为<code>article</code>的和<code>body</code>的, 主要职能就是展示脚注, 引用目录, 附加信息, 地址邮件等.</p><p><img src="https://i.loli.net/2021/02/12/7ZPoc5ApFXy3zRb.png" alt="image-20210212121917346"></p><h4 id="2-内嵌元素"><a href="#2-内嵌元素" class="headerlink" title="2. 内嵌元素"></a>2. 内嵌元素</h4><ul><li><p><code>h1</code>~`h6 <code>\ </code>hgroup`: 一般h1\h2再用hgrop包裹就是一个基本的标题组, 还可在html中生成目录结构</p></li><li><p><code>nav</code> –导航标签, 用于链接页面形成目录索引, 内部有ol\ul和li.</p></li><li><p><code>strong</code>和<code>em</code>, <code>b</code>和<code>i</code> 的异同: </p><ul><li><p>b、i属于<strong>修饰类标签</strong>；strong、em属于<strong>内容类标签</strong></p></li><li><p>b、strong标签表现为<strong>加粗</strong>；em、i表现为<strong>倾斜</strong></p></li><li><p>strong、em表<strong>强调</strong>；strong比em语气更强烈；strong在<strong>页面</strong>上的强调，而em是更多在<strong>语义</strong>上强调</p></li><li><p>strong和em真正做到了结构与样式分离，而b、i没有做到结构与样式的分离</p></li><li><p>在搜索引擎优化strong和em比b和i重要的多。</p></li></ul></li><li><p><code>figure</code> –图表, 和<code>figcaption</code> 描述一起使用, 用于描述独立的图片与文字组合.</p></li><li><p><code>cite</code> –引用, 在论文中常见.</p></li><li><p><code>mark</code> –高亮, 读者角度, 高亮文本.</p></li><li><p><code>detail </code> –挂件, 形式为下拉菜单. 和summary提供概要.</p></li><li><p><code>time</code> –时间, 可以让机器阅读更加方便.</p></li><li><p><code>pre</code> –预定义格式输出, 不改变排版, ( 输出字面量标签要更换为转义符, 如’&lt;’👉&amp;lt ).</p><ul><li><code>samp</code>–代码示例, 一般用于表示程序输出信息\非代码的程序部分.</li><li><code>code</code> –源代码.</li></ul></li></ul><p>可见, 结构元素以一条完整的主线, 串联起各个部分, W3C专家倡导的文字排版应用在web上, 体现web作为信息传播的重要途径和文字排版学问的广博.</p><p>跑偏了, 我们要把握基本的结构, 再适当地使用内嵌其中的语义化标签, 形成良好的规范和结构.</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>语义化是相对简单地一个知识点, 本文不是在介绍各个标签的详细用法, 也并没有列出全部语义标签. 旨在标出个人认为形成语义化规范的<strong>重要且基础</strong>的部分. </p><p>是否要严格执行语义化, 要根据具体的业务需求, 对于<strong>传播目的性强\团队协作\规范严谨</strong>的一类网页可以加强这方面的实施, 对于<strong>功能目的性强的\业务效率优先</strong>的网页则可以简化. 语义化本身有些争议, 这是文本标记语言的特性决定的, 不像其他编程语言一样需要非常严谨的逻辑和规则.</p><p>当然, 文中提到的只是wiki文章中典型的语义化要求, 也可以抽象出通用的语义化要求:</p><ul><li><strong>文本层面语义化</strong></li><li><strong>结构层次的语义化</strong></li></ul><p>本文提供语义化思想的方法论, 届时更新更加深入的语义化优化方案.</p><h2 id="03-HTML元数据和链接"><a href="#03-HTML元数据和链接" class="headerlink" title="03 HTML元数据和链接"></a>03 HTML元数据和链接</h2><p>html元数据即在<code>head</code>标签中的部分, 主要是描述了网页的一些重要的信息和媒体链接.  大多情况下是提供给浏览器爬虫和机器阅读的.  链接作为网页的互联的基石, 在head中链接有<code>link</code>和<code>script</code>两种形式. </p><p>本文归纳常见的元数据和链接的重要知识.</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><ul><li><p>head</p><p>head本身没有意义, 只提供保存容器, 是Document的元数据集合. 不会在页面上显示, 且只有一个title和base.</p></li><li><p>title</p><p>网页html文档标题, 而非网页内容标题( h1~h6), 主要在搜索中体现重要性, 对于整个文档的概括性. 这个标题在其他上下文中也会被使用，例如在用户的历史、书签，或搜索结果中</p></li><li><p>base</p><p>给网页上的URL提供相对地址的基础, 相当于<strong>根目录前缀</strong>, 只能有一个base. 它会改变全局的链接, 并不提倡使用.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.example.com/news/index.html&quot;</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Visit the <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;archives.html&quot;</span>&gt;</span>archives<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面例子中的链接地址是 “<code>https://www.example.com/news/archives.html</code>“。</p></li><li><p>style</p><p>css样式表</p></li></ul><h4 id="最重要的meta"><a href="#最重要的meta" class="headerlink" title="最重要的meta"></a>最重要的meta</h4><p>meta是作为title, base, link等的补充, 而实际上meta类型是开发者常见的优化方向. 本质是key-value.</p><p>使用meta要注意:</p><ul><li>必须指定任意一个: <code>name</code>，<code>http-equiv</code>，<code>charset</code>， 和 <code>itemprop</code>( 除了itemprop其他的都要同时指定content)</li><li>每个文档必须存在不少于一个有 <code>charset</code> 属性的 <code>meta</code> 元素。</li></ul><p>可以自定义meta, 约定好name和value即可, 也可以使用预定义的规范meta.</p><p>主要预定义的类型有这几项:</p><ol><li><p>html5简化了meta的charset写法, 新增charset属性用于设置网页的编码. 即:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>进行utf-8(ASCII是utf-8的子集)编码是因为一般http请求过程, 服务器会设定编码格式, 但应对一些非http协议无请求头, 如file, 就可以避免乱码情况.</p></li><li><p>具有http-equiv属性的meta, 执行命令, 一般是添加http头, 即content-type, 可以同时设定编码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;content-type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>name为viewport的meta, 设置网页缩放, 响应式设计中最常用.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述是移动端响应式设计中最典型的使用, 其中content设置<code>key</code>=<code>value</code>, 中间使用逗号分隔.</p><p>属性解释:</p><ul><li>width：页面宽度，可以取数值，一般设置成 device-width，即设备宽度。 </li><li>height：页面高度，可以取数值，一般设置成 device-height，即设备高度。 </li><li>initial-scale：初始缩放比例. (一般为1)</li><li>minimum-scale：最小缩放比例。 (一般为1)</li><li>maximum-scale：最大缩放比例。 (一般为1)</li><li>user-scalable：是否允许用户缩放。(对于移动端已有响应式设计就设置为no)</li></ul></li><li><p>description\application-name, 前者描述网页, 后者提供网页应用的名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">application-name</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;mugu&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;this is a description&gt;</span></span><br></code></pre></td></tr></table></figure><p>对于description, 在网页搜索中比较重要, 对于信息的提取也比较高效</p><p>而application-name是为网页应用设置的, 可以用作标签收藏时的使用, 利于浏览器算法生成.</p></li><li><p><strong>keyword弃用</strong>, 很多搜索引擎不会考虑这些关键字，因为该特性是不可靠的甚至会导致垃圾结果，对用户并没有帮助。特别是面对一些作弊, 恶意填充的keyword, 浏览器搜索引擎基本不作为考量.</p></li><li><p>referrer, generator, theme-color……</p></li></ol><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接包括两种, <strong>超链接</strong>和<strong>外部资源</strong>链接, 其中核心就是互联网的URL和URI系统.</p><p><strong>URI 指的是一个资源，URL 指的是用地址定位一个资源，URN 指的是用名称定位一个资源。 即URL 和 URN 是 URI 的子集。</strong> 详细可见引用[4]</p><p>在网页中链接最重要的两个属性是<strong>rel</strong>和<strong>href</strong>, 前者是Relationship, 指链接目标文档和本文档的关系; 后者表示Hypertext Reference, 指超链接的目标地址. 把握这两者的对应关系可以更好的理解和使用响应的标签.</p><p>网页中的链接主要有以下:</p><h4 id="link"><a href="#link" class="headerlink" title="link"></a>link</h4><ol><li>rel属性, 不同的功能</li></ol><p>link最主要的使用时链接外部资源. 即<strong>外部资源类链接</strong>. 常见在head标签中, 进行<strong>stylesheet</strong>关系的css文件引用.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;theme.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>大多情况向link不会显示在网页中, 作为元数据的一类, 其设计的目的是为了浏览器和搜索引擎识别. 比如icon资源, 会被浏览器识别:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/atom+xml&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/blog/news/atom&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 移动端提供不同分辨率, 此处的apple开头rel为ios特有 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;114x114&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon114.png&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;72x72&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon72.png&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此外指定不同的rel可以有不同的功能, 如<strong>preload</strong>预加载一些资源文件( 只是缓存, 未执行, 同常加上type属性声明MIME类型 ); 使用<strong>prerender</strong>可以预渲染页面, 这在确定用户会接下的页面中设置, 来访问可以极大提升用户体验.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;sintel-short.mp4&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;video&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prerender&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>as</code>属性指定加载资源的类型，它的值一般有下面几种。</p><ul><li>script</li><li>style</li><li>image</li><li>media</li><li>document</li></ul><p>还有一些其他信息类的元数据用途, 即提供给搜索引擎\浏览器等, 此类一般为<strong>超链接类链接</strong>, 当rel指明为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 作者信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;humans.txt&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 版权信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;license&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;copyright.html&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 另一个语言的版本, 通常由搜索引擎判别; 也可由插件判断RSS订阅链接 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://es.example.com/&quot;</span> <span class="hljs-attr">hreflang</span>=<span class="hljs-string">&quot;es&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/atom+xml&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/blog/news/atom&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 联系方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;me&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://google.com/profiles/someone&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/html&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;me&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:name@example.com&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;me&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;sms:+15035550125&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 历史资料 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;archives&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/archives/&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 目录 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 导航, 主要在分页浏览的业务场景中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;first&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;last&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/?page=42&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prev&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/?page=1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;next&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/?page=3&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 部分来自wangdoc.com --&gt;</span><br></code></pre></td></tr></table></figure><p>当然有些已经被meta元数据替代.</p><ol start="2"><li><p>media属性, 外部资源生效的媒介条件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;print.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;print&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mobile.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen and (max-width: 600px)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>和css的媒体查询类似, 在不同条件下, 加载不同的文件资源.</p></li><li><p>其他属性</p><p><code>&lt;link&gt;</code>标签的其他属性如下。</p><ul><li><code>crossorigin</code>：加载外部资源的跨域设置。</li><li><code>href</code>：外部资源的网址。</li><li><code>referrerpolicy</code>：加载时<code>Referer</code>头信息字段的处理方法。</li><li><code>as</code>：<code>rel=&quot;preload&quot;</code>或<code>rel=&quot;prefetch&quot;</code>时，设置外部资源的类型。</li><li><code>type</code>：外部资源的 MIME 类型，目前仅用于<code>rel=&quot;preload&quot;</code>或<code>rel=&quot;prefetch&quot;</code>的情况。</li><li><code>title</code>：加载样式表时，用来标识样式表的名称。</li><li><code>sizes</code>：用来声明图标文件的尺寸，比如加载苹果手机的图标文件。</li></ul></li></ol><h4 id="a"><a href="#a" class="headerlink" title="a"></a>a</h4><p>a标签指anchor, 即锚点, 在网络中定下信标就是a标签的功能. a标签于link同样具有rel和href, 也可充当元数据, 且rel的:</p><p>alternate \ author \ help \ license \ next \ prev \ search</p><p>与link的语义相同, 不同的是, <strong>a会显示在页面上,</strong> 更多是阅读用途. </p><p>除了常用的链接, 还有几个比较重要的用法:</p><ul><li><p><strong>download</strong>属性, 表示当前链接用于下载, 如下例, 文件名为bar.exe, 也可省略.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;foo.exe&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;bar.exe&quot;</span>&gt;</span>点击下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，如果链接点击后，服务器的 HTTP 回应的头信息设置了<code>Content-Disposition</code>字段，并且该字段的值与<code>download</code>属性不一致，那么该字段优先，下载时将显示其设置的文件名。</p></li><li><p><strong>mailto</strong>协议, 打开本机默认的邮件程序发送邮件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:contact@example.com&quot;</span>&gt;</span>联系我们<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 详细用法可以指定邮件的主题\日期等, 注意需要转义, %20为空格 --&gt;</span><br>&lt;a<br>  href=&quot;mailto:foo@bar.com?cc=test@test.com&amp;subject=The%20subject&amp;body=The%20body&quot;<br>&gt;发送邮件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 分享网页的用法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:&quot;</span>&gt;</span>告诉朋友<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><p>作为交互的灵魂, script标签加载脚本代码, 执行JavaScript程序. </p><p>最重要的就是type属性, 一般默认是”text/javascript”. 还有下面一些其他属性，大部分跟 JavaScript 语言有关.</p><ul><li>async：该属性指定 JavaScript 代码为异步执行，不是造成阻塞效果，</li><li>JavaScript 代码默认是同步执行。</li><li>defer：该属性指定 JavaScript 代码不是立即执行，而是页面解析完成后执行。</li><li>crossorigin：如果采用这个属性，就会采用跨域的方式加载外部脚本，即 HTTP 请求的头信息会加上origin字段。</li><li>integrity：给出外部脚本的哈希值，防止脚本被篡改。只有哈希值相符的外部脚本，才会执行。</li><li>nonce：一个密码随机数，由服务器在 HTTP 头信息里面给出，每次加载脚本都不一样。它相当于给出了内嵌脚本的白名单，只有在白名单内的脚本才能执行。</li><li>referrerpolicy：HTTP 请求的Referer字段的处理方法。</li></ul><p><code>&lt;noscript&gt;</code>标签用于浏览器不支持或关闭 JavaScript 时，所要显示的内容. noscript不是一个功能性标签, 我个人感觉更像是一种人性化的设计, 虽然有些争议, 但是在某些层面noscript照顾到一部分人的利益. 可以查阅这篇博客<a href="https://www.smashingmagazine.com/2018/05/using-the-web-with-javascript-turned-off/">🔗I Used The……</a>[5]</p><p>要注意的是href和src虽然都是提供了URL, 但是两种用本质区别, 即前者为替换型标签, 引入资源后替换自身, 如script. 但href则是链接到外部的标签.</p><p>那为什么style标签不能像script一样使用src呢? 而是要link链接? 下篇博客详细讨论相关内容和媒体标签的引用.</p><p>以上为链接相关的内容.</p><p><em>引用</em></p><ol><li>HTML Standard. (2021). Retrieved 18 February 2021, from <a href="https://whatwg-cn.github.io/html">https://whatwg-cn.github.io/html</a></li><li>文档级元数据元素 - HTML（超文本标记语言） | MDN. (2020). Retrieved 18 February 2021, from <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta</a></li><li>链接标签. (2021). Retrieved 19 February 2021, from <a href="https://wangdoc.com/html/link.html">https://wangdoc.com/html/link.html</a></li><li>URI、URL 和 URN 的区别. (2019). Retrieved 19 February 2021, from <a href="https://juejin.cn/post/6844904003348725767">https://juejin.cn/post/6844904003348725767</a></li><li>I Used The Web For A Day With JavaScript Turned Off — Smashing Magazine. (2018). Retrieved 19 February 2021, from <a href="https://www.smashingmagazine.com/2018/05/using-the-web-with-javascript-turned-off/">https://www.smashingmagazine.com/2018/05/using-the-web-with-javascript-turned-off/</a></li></ol><h2 id="04-HTML嵌入型元素-媒体标签"><a href="#04-HTML嵌入型元素-媒体标签" class="headerlink" title="04 HTML嵌入型元素(媒体标签)"></a>04 HTML嵌入型元素(媒体标签)</h2><p>上篇博客提到了链接, 主要讲述的是link, a, script等链接型元素. 与之相对的是嵌入在网页中的内容, 嵌入内容对应的嵌入型元素主要是一些多媒体标签. 它们主要是img, video, audio, iframe等. 本文一一复盘.</p><h4 id="为什么style标签没有src"><a href="#为什么style标签没有src" class="headerlink" title="为什么style标签没有src?"></a>为什么style标签没有src?</h4><p>开始复盘前, 先理解一下嵌入型和链接型的区别.</p><p><img src="C:\Users\Mr.yang\AppData\Roaming\Typora\typora-user-images\image-20210220221057875.png" alt="image-20210220221057875"></p><p>相关tweet中, 老哥的这段话的大意是:  网页中某个具有src属性的标签, 是让浏览器去<strong>引用并嵌入</strong>到这个标签的位置.</p><p>而从功能角度思考, stylesheets作用在整个文档, 和文档是有对应的, 明确的<strong>1对1的映射关系</strong>. 而非其他嵌入在其中的包含关系. 所以, 有以下可能的原因和结论:</p><ul><li><p>style标签与页面不是嵌入关系, 故没有src, 至于为什么没有href, 而是用link来描述样式表, 可能是</p><ul><li>有一定的<strong>历史遗留和设计原因</strong>, 起初的css发展和html不同步, 可能有设计层面的原因</li><li>link更能<strong>抽象和描述</strong>样式表这一外部文件和文档的关系.</li></ul></li><li><p><strong>包含src的元素是嵌入型, 包含href的是链接型元素</strong></p></li></ul><p>其实, script标签和页面也可以归纳为一种对应关系, 应该也可以使用link去引入. 但是个人认为, 从浏览器工作层面考量则应更注重内联和引用的层面. 所以部分知识有争议和待求解很正常, 需要用辩证, 客观的想法去学习, 没有本来就那样的道理, 学会从语言设计层面去思考问题.</p><h4 id="嵌入型多媒体标签"><a href="#嵌入型多媒体标签" class="headerlink" title="嵌入型多媒体标签"></a>嵌入型多媒体标签</h4><ol><li><p><strong>img</strong></p><p>img是大家非常熟悉的标签了, 基础略过, 一些重要的属性和优化如下:</p><ul><li><p><strong>alt</strong></p><p>alt这个属性一般用户没有什么感受, 最多在图片加载失败时候, 看到一张破碎的图标和”img”的字样.</p><p>事实上, alt是对于视障人士最大的关怀. alt可以放置描述性的文字用以机器阅读, 是特别重要但又容易被忽略的一点.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;一只小狗在奔跑&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>正确的alt应该是如上面所示, 描述图片, 而非”图片”, “示例图片”, 这也是容易被忽略的. 这是做到网址可达性的重要一点.</p></li><li><p><strong>loading</strong></p><p>设置懒加载, 对于浏览较多, 较长的图文会非常有用, 只有当用户交互到的时候才进行加载, 即节省带宽流量, 有提高网页加载速度. </p><p>loading属性可以取以下三个值。</p><blockquote><ul><li><code>auto</code>：浏览器默认行为，等同于不使用<code>loading</code>属性。</li><li><code>lazy</code>：启用懒加载。</li><li><code>eager</code>：立即加载资源，无论它在页面上的哪个位置。</li></ul></blockquote><p>由于图片的懒加载, 会导致页面重排, 影响性能. 所以一般设置好宽高.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.png&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;…&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>data uris</strong></p><p>这类data:uri的图片引入也是常用的技巧, <strong>用来减少文件的引入, 从而减少http请求, 提升网页性能</strong>. 替换调url为data uris. 格式如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">data:[<span class="hljs-tag">&lt;<span class="hljs-name">mime</span> <span class="hljs-attr">type</span>&gt;</span>][;charset=<span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>][;base64],<span class="hljs-tag">&lt;<span class="hljs-name">encoded</span> <span class="hljs-attr">data</span>&gt;</span><br></code></pre></td></tr></table></figure><p>常见的就是base64的图片编码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;star&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;16&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;16&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以通过一些在线的网址提取图片的base64编码, 比如这个<a href="https://websemantics.uk/tools/image-to-data-uri-converter/">online base64 converter</a></p><p>转换后base64的图片相比原来的可能会增加30%的大小, 因为通过较长的字符串来替代, 所以会<strong>降低可读性</strong>, 同时如果写在css中, 会<strong>增加css的体积</strong>, 但是可以通过压缩解决这个问题. 但是用base64有更明确的场景条件:</p><ul><li>被编码的图片较小, 且复用性高, 不经常刷新. 如用50X50字节的图片去平铺背景图</li><li>不用额外的请求</li><li>无法使用cssSprite的独立性较高的图片.</li></ul><p>特别是<strong>数量大, 独立性强, 体积小</strong>的图片. 这点和cssSprite比较像, 但两者还是有区别的. 可以参考这位博主的分析, <a href="https://www.imooc.com/article/27804"><strong>图片Base64编码的利与弊分析</strong></a>.</p><p>不要盲目使用base64, 不是说可以减少图片请求就可以提高网页速度, 要<strong>因地制宜地使用</strong>, 否则: </p><p><img src="https://i.loli.net/2021/02/21/61IEzpmohqOWaSV.png" alt="image-20210221111951829"></p><p>(应该是主要用base64)加载图片的网址比单纯使用二进制链接(即src等)的网址慢了6倍!</p></li><li><p><strong>srcset, sizes</strong></p><p>srcset可以为图片设置不同url地址, 主要用于移动端的<strong>响应式设计</strong>, 采用不同的图片尺寸来实现.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;foo-160.jpg 160w,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-320.jpg 320w,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-640.jpg 640w,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-1280.jpg 1280w&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;(max-width: 440px) 100vw,</span></span><br><span class="hljs-tag"><span class="hljs-string">            (max-width: 900px) 33vw,</span></span><br><span class="hljs-tag"><span class="hljs-string">            254px&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo-1280.jpg&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;foo-320w.jpg,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-480w.jpg 1.5x,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-640w.jpg 2x&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo-640w.jpg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>srcset</code>属性给出了三个图像 URL，适应三种不同的<strong>像素密度</strong>.</p><p>图像 URL 后面的像素密度描述符，格式是像素密度倍数 + 字母<code>x</code>。<code>1x</code>表示单倍像素密度，可以省略。浏览器根据当前设备的像素密度，选择需要加载的图像。</p><p>如果<code>srcset</code>属性都不满足条件，那么就加载<code>src</code>属性指定的默认图像。</p><p>而 <code>sizes </code>属性, 则是用于选择不同的<strong>屏幕宽度</strong>. 当不同尺寸的条件发生, 则显示不同宽度的图片.</p><p>事实上, 更好的做法是使用picture标签. 同时兼具像素和屏幕选择的两种功能.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/svg+xml&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;logo.xml&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/webp&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;logo.webp&quot;</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;ACME Corp&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>video</strong></p><p>去年正式歇菜Flash一度是web视频的独有者, h5播放器如今发展得越来越好. 一般来说, 会指定多个视频源:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br> You browser does not support video.<br>&lt;/video<br></code></pre></td></tr></table></figure><p>上面三种是video支持的主流视频格式. 分别是VP8 \ Theroa \ H.264对于的协议专利.至于为什么没有统一的h5的是视频格式, 可以追溯到各个厂家的竞争, 参考阮一峰翻译的<a href="http://www.ruanyifeng.com/blog/2010/05/html5_codec_fight.html">HTML5的视频格式之争</a>.</p><p>不支持h5播放器就会显示标签中的内容. 同时可以参考各个属性进行设置, 参见MDN.</p><p>audio属性基本和video一致.</p></li><li><p><strong>iframe</strong></p><p>iframe在网页开辟新的文档空间. 一般通过iframe嵌入其他网页. iframe并不被推荐使用, 一方面是网络安全问题, 容易利用iframe的漏洞进行攻击; 另一方面, 移动端显示问题, 还有诸多限制……此外还涉及到跨域问题. 一般网站都会通过http头禁止自身被设置为iframe.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-FRAME-OPTIONS&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;DENY&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新标准增加了sandbox, 更加方便设置, 可以解决跨域问题, 权限管理等:</p><p><code>sandbox</code>属性可以设置具体的值，表示逐项打开限制。未设置某一项，就表示不具有该权限。具体可以查看MDN.</p><p>注意，不要同时设置<code>allow-scripts</code>和<code>allow-same-origin</code>属性，这将使得嵌入的网页可以改变或删除<code>sandbox</code>属性。</p></li></ol><p><em>参考引用</em></p><ol><li>Data URIs | CSS-Tricks. (2010). Retrieved 21 February 2021, from <a href="https://css-tricks.com/data-uris/">https://css-tricks.com/data-uris/</a></li><li>Foskett, M. (2020). Image to base64 data-URI converter. Retrieved 21 February 2021, from <a href="https://websemantics.uk/tools/image-to-data-uri-converter/">https://websemantics.uk/tools/image-to-data-uri-converter/</a></li><li>&lt;img&gt;：图像嵌入元素 - HTML（超文本标记语言） | MDN. (2020). Retrieved 21 February 2021, from <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img</a></li><li>图像标签. (2021). Retrieved 21 February 2021, from <a href="https://wangdoc.com/html/image.html">https://wangdoc.com/html/image.html</a></li></ol><h2 id="05-HTML表格表单和ARIA"><a href="#05-HTML表格表单和ARIA" class="headerlink" title="05 HTML表格表单和ARIA"></a>05 HTML表格表单和ARIA</h2><p>本篇博客大致回忆下表单表格的特点, 用法和注意事项. 还有重点复盘下ARIA系统的概念.</p><h3 id="为什么不建议用要表格"><a href="#为什么不建议用要表格" class="headerlink" title="为什么不建议用要表格?"></a>为什么不建议用要表格?</h3><p>感兴趣可以先上StackOverflow查看这个当时table正火的帖子:</p><p><a href="https://stackoverflow.com/questions/83073/why-not-use-tables-for-layout-in-html">Why not use tables for layout in HTML? [closed]</a></p><p>你要是看了高赞的分析, 估计对table的弊端有大致的了解了. 个人认为web的发展并没有改变多少table的本质.</p><p><em>html的 <strong><code>table</code></strong> 元素表示表格数据 — 即通过二维数据表表示的信息</em>  –MDN</p><p>table本意就是拿来渲染表格数据的, 按道理来说没什么问题, 各司其职. 但是主要涉及三个问题:</p><ul><li><strong>SEO和语义化问题</strong>, 事实上, <code>table</code> 并没有很好地语义化, 想象下, 大量的<code>table</code> 数据内容混杂, 用户搜索自然也不会集中到数据本身, 搜索权重自然就小. 而且本身的阅读性不是很好, 设计太过朴素难以突出重点, 特别是现在花里胡哨的网站中.</li><li><strong>可访问性(Accessibility)差</strong>, 特别在屏幕阅读和视障人群地使用中, 遇上大量数据很难阅读和被正确地识别. 基本措施是&lt;caption&gt;\ &lt;summary&gt;进行表格数据描述, 或是设置scope属性等.</li><li><strong>浏览器渲染性能问题</strong>, <code>table</code> 的性能一直被人们诟病. 特别是在渲染方面, 需要表格加载完毕才开始渲染布局, 会有明显的割裂感和延迟. 主要和浏览器的渲染算法有关, 特别应对大量数据时, 缓存也是个问题.</li></ul><p>HTML设计思想是<strong>内容样式分离的</strong>, 使用CSS样式表来管理样式. 而这个<code>table</code> 却是兼具两者, 所以在浏览器行为方式不同也可以理解, 而且CSS更容易缓存. 目前<code>table</code> 的大量全局属性被抛弃<sup><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table#%E5%B1%9E%E6%80%A7">MDN🔗</a> </sup>, 建议使用CSS管理样式, 也说明了W3C正在分解<code>table</code> . </p><p>不论怎样, 目前都是不建议使用<code>table</code> 进行布局的, 要我说直观点就是排版麻烦不好看, 还有各种小毛病XD.</p><p>基本用法可以参考阮一峰 <a href="https://wangdoc.com/html/table.html">表格标签🔗</a>.</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>表单可以说是学习web中第一个碰到交互最多的组件. </p><p><code>name</code> 和<code>id</code> 的疑惑, 刚开始学习HTML的时候, 觉得<code>name</code> 和<code>id</code> 在大多数情况下的用途是一样的, 为什么不合并呢? 而在学习了<code>form</code> 之后, 才了解这样设计的部分原因. </p><ul><li><p><code>label</code>标签对应一个<code>input</code>, 关联的是<code>input</code>的<code>id</code>属性, 而非<code>name</code>属性, 此外除了常用的并列排布, 还可以包裹, 这是可以省略<code>for</code>和<code>id</code>属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名：<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>name</code> 属性是关系到服务器的字段信息获取, 需要通过<code>name</code>来获取属性.<br>此外表单的单选操作中会设置同个<code>name</code> .</p></li></ul><p>基本用法参考阮一峰 <a href="https://wangdoc.com/html/form.html">表单标签🔗</a>. 基础上没什么可以总结提炼的, 反观国内的框架也主要的是围绕<strong>表单优化</strong>展开. 而最重要的, 除了网络优化, 就是用户体验.</p><p>在用户体验方面, 可看看这篇博客 <a href="https://cxl.com/blog/form-design-best-practices/">Form Design: 13 Empirically Backed Best Practices</a>. 总结了一下重要的表表单开发和优化经验:</p><ul><li><p><strong>少即是多</strong>, 减少输入框👇( 对比两图, 后面多清爽 )<br><img src="https://i.loli.net/2021/02/25/wTonAbDg2NceBZ9.jpg" alt="img"><br><img src="https://i.loli.net/2021/02/25/nQp1E8MZFTYKtUG.png" alt="image-20210225234802974"></p></li><li><p><strong>单流</strong>向结构更易读, 更高效. 特别是移动端设备占主要成分的情况下.<br><img src="https://i.loli.net/2021/02/25/TsZtiYr5Nzmc43S.jpg" alt="image comparing a single-column vs. multi-column form design."></p></li><li><p>做好跟随的<strong>内联校验</strong>. 提高表单填写效率, 而非提交后才提示失败信息, 会严重挫败用户体验.</p></li><li><p>设置<strong>自动聚焦</strong>, 特别是移动端</p></li><li><p>增加<strong>显示密码</strong>, 有调查表明, 掩饰密码实际上没有对安全有多少影响, 反倒不变用户校验. 所以个人认为增加明文显示以供校验更加友好. can’k参考github的登陆界面:<br><img src="https://i.loli.net/2021/02/25/MEYkt3f1KrsvgS5.png" alt="image-20210225235656213"></p></li></ul><p>此外, 还有两点值得注意:</p><ul><li><p><strong>移除form表单默认跳转事件</strong>, <code>form</code> 和服务器打交道, 较多使用ajax技术进行提交, 为了防止默认的提交行为导致后续代码无法执行( 如弹窗, 回调函数等 ), 可以使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> submit = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">//移除默认行为</span><br>    $(<span class="hljs-string">&#x27;form&#x27;</span>).on(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        e.preventDefault();<br>        <span class="hljs-comment">//ajax请求代码:</span><br>        <span class="hljs-comment">//....</span><br>        &#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>防止重复提交</strong>. 策略可以是页面跳转, 前端校验式添加锁机制( 用默个字段控制状态 ), 后端服务器字段校验等.</p></li></ul><h3 id="ARIA"><a href="#ARIA" class="headerlink" title="ARIA"></a>ARIA</h3><p>ARIA全称: Accessible Rich Internet Applications 可访问富互联网应用, 即大家口中的无障碍, 是一个<strong>可访问性的标准</strong>.  有时候你会看到WAI-ARIA, 其中WAI = Web Accessibility Initiative, 即无障碍网页倡议. 两者指代的都是同意思.</p><p>可以把它当作HTML5标签的<strong>属性扩展</strong>. 主要可以<strong>支持屏幕阅读等辅助技术, 提供语义化信息</strong>. </p><p>现代浏览器基本支持ARIA, 即使不支持也不会造成问题, <strong>ARIA并不会改变标签的功能表现</strong>. </p><p>ARIA是在HTML4之后引入的, 更像是一个过渡时期的机制. 因为<strong>许多ARIA规范在HTML5中已经实现语义化</strong>标签, 但是仍然发挥着重要的补充功能.</p><h4 id="ARIA不只是视障关怀"><a href="#ARIA不只是视障关怀" class="headerlink" title="ARIA不只是视障关怀"></a>ARIA不只是视障关怀</h4><p>初识AIRA可能会误解为专为视障用户使用的关怀手段. 实际上, ARIA属于可访问性的范畴, 从语义化 \ 辅助阅读等角度都是AIRA的重点, HTML5实现相关ARIA属性为标签也可见一斑. 所以ARIA不只是特定用户的辅助技术, <strong>更是衡量一个优秀网站的标准</strong>.</p><p>而且, 对于javascript程序为基础的web应用, 许多功能 \ 组件无法使用HTML标签去语义化表达, 这时候ARIA就发回了很大的扩展作用. </p><p>例如, 一个弹出式UI组件, 面包屑导航等在框架中常见的组件; 再从框架中的组件中也可以看出目前HTML没有的语义化表达.</p><h4 id="实现原理和应用"><a href="#实现原理和应用" class="headerlink" title="实现原理和应用"></a>实现原理和应用</h4><p>ARIA 通过更改和补充标准 DOM 无障碍树来发挥作用。而且<strong>ARIA 不会补充元素的任何固有行为</strong>；</p><p><img src="https://i.loli.net/2021/02/26/4xEBWCaZ1sDzPFQ.png" alt="image-20210226173451402"><img src="https://i.loli.net/2021/02/26/ojC4g7eX6LM5ir3.png" alt="image-20210226173512018"></p><p>通过DOM的修改\创建不存在HTML标签中的语义化元素, 大概可以实现以下功能:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 扩展语义, eg:创建了一的只读标签 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;screen reader only label&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 定义父子组件的关系, eg:控制特定区域的自定义滚动条 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;scrollbar&quot;</span> <span class="hljs-attr">aria-controls</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><br>. . .<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 辅助技术API, eg:页面发生变化时立即通知辅助技术 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">aria-live</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>GOOG: $400<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>......<br></code></pre></td></tr></table></figure><h4 id="role体系"><a href="#role体系" class="headerlink" title="role体系"></a>role体系</h4><p>ARIA 系统的其中一个核心层面是其<code>role</code>集。在无障碍术语中，角色是指特定 UI 模式的简略指示器.</p><p><strong>换句话说, 可以将下面属性值理解成新的未纳入规范的语义化标签.</strong></p><p><img src="https://i.loli.net/2021/02/26/5dSkZFcGXRNJbxB.png" alt="image-20210226112447841"></p><p>可见, 有些<code>role</code> 在h5中成为了新标签( 图中红框圈出了部分 ), 把ARIA看出过渡也是一种观点. </p><p>看一看<code>role</code> 属性如何使用:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;timer&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;tomato-timer&quot;</span> <span class="hljs-attr">aria-roledescription</span>=<span class="hljs-string">&quot;这是个番茄钟, 计时25分钟&quot;</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span>25mins<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;startTimer(&#x27;clock&#x27;)&quot;</span>&gt;</span>开始计时<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义了<code>timer</code>这个计时器, 相关的<code>aria- </code> 属性让辅助手段判断其UI变化. 一般这种变化是通过js操作的, 而且<code>aria-</code> 更多在js应用中使用.</p><p>此处<code>timer</code> 对应的<code>aria-label</code> 描述其名称, <code>aria-roledescription</code> 添加更加具体的说明以供屏幕阅读器朗读等.</p><p>在WAI-ARIA中可以找到各个<code>role</code> 对应的属性  <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles">aria role🔗</a></p><p>role的使用很简单, 要更好地认识可以将其粗略分为widget部件和section组成:</p><ul><li><strong>widget</strong><ul><li>功能型:  button, alert, link, timer, progressbar, scrollbar, separator</li><li>表单型:  checkbox, radio, option, slider, slider, textbox, spinbutton</li><li>复合型:  tab, tree,  menu, list, grid…..</li></ul></li><li><strong>section</strong><ul><li>h5中实现了很大一部分, 请直接使用. 如article, </li><li>Landmark, 直接翻译地标, ARIA标准中的<strong>八结构页面</strong>组成:<ul><li>Banner  ( 开发习惯常用banner头图 )</li><li>Navigation  ( eg: nav标签, 导航栏 )</li><li>Form  ( 表单 )</li><li>Main   ( 主体 )</li><li>Application  ( web应用本身 )</li><li>Search  ( 搜索功能 )</li><li>complementary  ( eg: aside标签补充说明, 辅助内容 )</li><li>contentinfo  ( 内容注释, meta内容, 版权信息© )</li></ul></li></ul></li></ul><h4 id="AIRA的启发"><a href="#AIRA的启发" class="headerlink" title="AIRA的启发"></a>AIRA的启发</h4><p>可见, ARIA是更加抽象的标签, 对于理解网页结构, 文字排版等有重大的启发意义. 特别在进行组件设计时, 可以参考ARIA的设计思想, <strong>由概念到属性, 进一步抽象, 封装成可用组件.</strong> 很多UI框架的组件就可以看成高一层的封装, 如各种tabbar\scroll-view\list等等.</p><p><em>引用</em></p><ol><li><p>&lt;table&gt;- HTML（超文本标记语言） | MDN. (2020). Retrieved 26 February 2021, from <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table</a></p></li><li><p>ARIA - 无障碍 | MDN. (2020). Retrieved 26 February 2021, from <a href="https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/ARIA">https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/ARIA</a></p></li><li><p>Introduction to ARIA  | Web Fundamentals  | Google Developers. (2021). Retrieved 26 February 2021, from <a href="https://developers.google.com/web/fundamentals/accessibility/semantics-aria#:~:text=%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3,%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%A3%B0%E6%98%8E%E3%80%82">https://developers.google.com/web/fundamentals/accessibility/semantics-aria#:~:text=%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3,%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%A3%B0%E6%98%8E%E3%80%82</a></p></li><li><p>Birkett, A. (2019). Form Design: 13 Empirically Backed Best Practices | CXL. Retrieved 26 February 2021, from <a href="https://cxl.com/blog/form-design-best-practices/">https://cxl.com/blog/form-design-best-practices/</a></p></li><li><h4 id="ARIA-Landmark-Roles-2021-Retrieved-26-February-2021-from-https-www-washington-edu-accessibility-web-landmarks"><a href="#ARIA-Landmark-Roles-2021-Retrieved-26-February-2021-from-https-www-washington-edu-accessibility-web-landmarks" class="headerlink" title="ARIA Landmark Roles. (2021). Retrieved 26 February 2021, from https://www.washington.edu/accessibility/web/landmarks/"></a>ARIA Landmark Roles. (2021). Retrieved 26 February 2021, from <a href="https://www.washington.edu/accessibility/web/landmarks/">https://www.washington.edu/accessibility/web/landmarks/</a></h4></li><li><p>表格标签. (2021). Retrieved 26 February 2021, from <a href="https://wangdoc.com/html/table.html">https://wangdoc.com/html/table.html</a></p></li><li><p>表单标签. (2021). Retrieved 26 February 2021, from <a href="https://wangdoc.com/html/form.html">https://wangdoc.com/html/form.html</a></p></li></ol><p><em>转发备注出处, thanks~</em></p>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript闭包简易指南</title>
    <link href="/2020/07/24/JavaScript%E9%97%AD%E5%8C%85%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97(%E7%BF%BB%E8%AF%91)/"/>
    <url>/2020/07/24/JavaScript%E9%97%AD%E5%8C%85%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97(%E7%BF%BB%E8%AF%91)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript闭包简易指南-翻译"><a href="#JavaScript闭包简易指南-翻译" class="headerlink" title="JavaScript闭包简易指南(翻译)"></a>JavaScript闭包简易指南(翻译)</h1><p>在学习闭包过程之中，发现了medium中一篇比较好理解的外国博客。为方便学习交流，在下初略翻译搬运，并在自己的理解上进行修改和添加了自己的内容.</p><p>本文适合初步了解闭包，只从作用域和函数执行过程两个角度简易解释闭包<br>深入认识闭包还要从设计模式、应用场景、浏览器垃圾回收机制和词法作用域（待更新）</p><p><a href="https://medium.com/@prashantramnyc/javascript-closures-simplified-d0d23fa06ba4">原文连接</a></p><hr><p>javascript中的闭包是让许多开发者头疼的东西。在下面的文章中，我将清楚地解释何为闭包，并使用简单的范例来阐述要点。</p><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是 JavaScript 中的一项<strong>功能</strong>，其中<strong>内部函数</strong>可以访问<strong>外部（封闭）函数的变量</strong><br>就是函数和函数变量所处作用域的混合</p><p>即形成 <strong>范围链</strong>(<em>即作用域链，个人认为范围链更容易理解</em>，)。</p><p>闭包有三个范围链：</p><ul><li>它有权访问自己的范围(作用域)——在其大括号<code>&#123;&#125;</code>之间定义的变量</li><li>它有权访问外部函数的变量</li><li>它可以访问全局变量</li></ul><p>小白看到这些行话有可能不太理解</p><p>(<em>可自行查阅MDN中的js作用域、变量等知识点</em>)</p><h2 id="为什么要用闭包"><a href="#为什么要用闭包" class="headerlink" title="为什么要用闭包?"></a><strong>为什么要用闭包?</strong></h2><h3 id="简单的闭包例子"><a href="#简单的闭包例子" class="headerlink" title="简单的闭包例子"></a>简单的闭包例子</h3><p>看看一个简单闭包的范例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;   <br>   <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(a+b);<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有两个功能：</p><ul><li>具有变量<code> b</code>的外部函数<code>outer</code>，返回值是<code>inner</code></li><li>具有变量<code>a</code>的内部函数<code>inner</code>，在其内部可以访问<code>outer</code>的变量<code>b</code></li></ul><p><code>b</code>的作用范围被限制在函数<code>outer</code>内，<code>a</code>则被限制在<code>inner</code>中</p><p>现在调用函数，并赋值存储到变量上。</p><p>然后，第二次调用同样的过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;   <br>   <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;     <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(a+b);<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>&#125;<br><span class="hljs-keyword">var</span> X = outer(); <span class="hljs-comment">//outer() invoked the first time</span><br><span class="hljs-keyword">var</span> Y = outer(); <span class="hljs-comment">//outer() invoked the second time</span><br></code></pre></td></tr></table></figure><p>一行一行来康康<code>outer</code>函数第一次执行过程</p><ol><li><p>变量<code>b</code>被创建，它的作用域是<code>outer</code>之内，此时赋值<code>b=10</code></p></li><li><p>这一行开始是函数声明</p></li><li><p><code>inner</code>结束后是<code>return inner</code>，发现返回的是个函数，此时返回整个<code>inner</code>函数体<br>[注意<code>return</code>并不会执行<code>inner</code>函数，只有<code>inner</code>被调用才执行]</p></li><li><p>被返回的内容被存储在变量<code>x</code>中， 即 <code>x = </code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">console</span>.log(a + b);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数执行结束， <code>outer</code>作用域内的所有变量都被释放，不再存在</p></li></ol><p>这个过程中第四步最为重要，要注意<strong>一旦函数结束执行，函数范围内的任何变量都将消失</strong></p><p><code>函数执行时间 === 函数内变量生存周期</code></p><p>既然这样， 当尝试调用<code>X</code>时，<code>outer</code>函数的执行已经结束，只在执行时存在变量<code>b</code>此时已经被释放，那么属于<code>outer</code>的变量<code>b</code>在<code>inner</code>中的<code>console.log(a + b)</code>就会报错， b应该是<code>undefined</code></p><p>当函数第二次执行，此时赋值给变量Y，重复上述过程<br>……</p><p>第二次执行的重点是，这时的变量都是全新的，同样符合:<br><code>函数执行时间 === 函数内变量生存周期</code></p><p>现在回到代码，看看<code>X</code>和<code>Y</code>，<code>outer</code>函数执行后都返回同样的函数给变量<code>X</code>和<code>Y</code>，那么<code>X</code>和<code>Y</code>也理所当然是函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//按f12在控制台中打印x和y的类型:</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(X)); <span class="hljs-comment">//X is of type function</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(Y)); <span class="hljs-comment">//Y is of type function</span><br></code></pre></td></tr></table></figure><p>执行<code>X</code>和<code>Y</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;     <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(a+b);<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>&#125;<br><span class="hljs-keyword">var</span> X = outer(); <br><span class="hljs-keyword">var</span> Y = outer(); <br><span class="hljs-comment">//end of outer() function executions</span><br>X(); <span class="hljs-comment">// X() invoked the first time</span><br>X(); <span class="hljs-comment">// X() invoked the second time</span><br>X(); <span class="hljs-comment">// X() invoked the third time</span><br><br>Y(); <span class="hljs-comment">// Y() invoked the first time</span><br></code></pre></td></tr></table></figure><p>不难看出实际上我们都在执行<code>inner</code></p><p>来一步一步看看执行过程:</p><ol><li>创建变量<code>a = 20</code></li><li>JavaScript 现在尝试执行 。这里是事情变得有趣的地方。JavaScript 知道存在变量<code>a</code>， 因为第一步刚刚创建它。<br>但是，根据变量生命周期，属于<code>outer</code>的<code>b</code>不再存在。<br><code>outer</code>函数早在我们调用<code>inner</code>之前就完成了执行，因此函数范围内的任何变量都不再存在</li><li>……</li></ol><p>*上面这个例子就是是要说明需要闭包的原因: <strong>只有函数跑起来的时候变量才存在</strong>，那么怎么使用哪些其他本应消失的变量*?</p><p>为了解决这个矛盾，JavaScript设计出闭包.</p><h2 id="闭-包"><a href="#闭-包" class="headerlink" title="闭 包"></a>闭 包</h2><p>上例阐述了:<br><code>inner</code>函数可以访问已经结束生命周期的<code>outer</code>函数中的变量<code>b</code></p><p>用一句话来解释闭包:<br>一个函数在已封闭的函数执行时，保存并且能够访问范围链内的局部变量(即已封闭的函数的变量)，此时产生的就是闭包</p><p>用轮子哥的话说(站在闭包的角度):<br><img src="https://i.loli.net/2020/07/24/MPqcvyFNmLp8b3Z.png" alt="img"></p><p>在我们的示例中，<code>inner</code>函数保留了执行<code>outer</code>函数时的值，并继续保留(称为’’封闭’’)</p><p>注意有个重点是:<br><strong>inner只有在使用到了外部的局部变量时，范围链内才出现闭包</strong></p><p>现在再理解以下范围链，注意到这条链中确实有变量<code>b</code>的值，因为<code>b</code>在<code>outer</code>函数执行时将闭包的值封闭在闭包内。</p><p>所以语句<code>console.log(a + b)</code>才能够正确执行，得到想要结果</p><p>您可以通过向上述示例添加以下代码行来验证这一点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;    <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(a+b);<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>&#125;<br><span class="hljs-keyword">var</span> X = outer(); <span class="hljs-built_in">console</span>.dir(X); <br><span class="hljs-comment">//use console.dir() instead of console.log()</span><br></code></pre></td></tr></table></figure><p>通过控制台打印出函数执行路径:<br><img src="https://i.loli.net/2020/07/24/h2zE1GfuCFnv7DM.png" alt="1_WB0SdempUbLxhVLMS2DvDA"></p><p>可以看到变量 <code>b=10</code> 保留在 <code>inner</code>中的<br>Scopes链→<br>    →Closure闭包<br>    →b : 10</p><p>现在回到文章开头提出的范围链并和闭包关联起来:</p><ul><li><p>它有权访问自己的范围(作用域)——变量<code>a</code></p></li><li><p>它有权访问外部函数的变量——变量<code>b</code></p></li><li><p>它可以访问全局变量</p></li></ul><h2 id="闭包的实际使用"><a href="#闭包的实际使用" class="headerlink" title="闭包的实际使用"></a>闭包的实际使用</h2><p>使用闭包的核心要点，让我们通过添加三行代码展示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> c = <span class="hljs-number">100</span>;   <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;    <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a= &quot;</span> + a + <span class="hljs-string">&quot; b= &quot;</span> + b);            a++;<br>         b++;<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>    <br>&#125;<br><span class="hljs-keyword">var</span> X = outer();  <span class="hljs-comment">// outer() invoked the first time</span><br><span class="hljs-keyword">var</span> Y = outer();  <span class="hljs-comment">// outer() invoked the second time</span><br><span class="hljs-comment">//end of outer() function executions</span><br>X(); <span class="hljs-comment">// X() invoked the first time</span><br>X(); <span class="hljs-comment">// X() invoked the second time</span><br>X(); <span class="hljs-comment">// X() invoked the third time</span><br><br>Y(); <span class="hljs-comment">// Y() invoked the first time</span><br></code></pre></td></tr></table></figure><p>运行这段代码，将在在控制台中看到以下输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=20 <span class="hljs-attribute">b</span>=10<br><span class="hljs-attribute">a</span>=20 <span class="hljs-attribute">b</span>=11<br><span class="hljs-attribute">a</span>=20 <span class="hljs-attribute">b</span>=12<br><span class="hljs-attribute">a</span>=20 <span class="hljs-attribute">b</span>=10<br></code></pre></td></tr></table></figure><p>让我们逐步检查此代码，看看到底发生了什么，并看到闭包的过程！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> X = outer();  <span class="hljs-comment">// outer() invoked the first time</span><br></code></pre></td></tr></table></figure><p><strong>初始调用函数outer</strong><br>这是调用的是<code>outer</code>，执行以下步骤：</p><ol><li>变量<code>b=10</code>， <code>c=100</code>被创建，作为参考命名为<code>b1，c1</code></li><li><code>inner</code>函数被返回并且复制给变量<code>X</code><br>此时变量<code>b</code>被使用到，因此被<code>inner</code>封闭到它的范围链内，即产生了闭包，这个闭包包含一个变量<code>b : 10</code></li><li><code>outer</code>函数完成执行，并且它的所有变量都不再存在。<br>变量<code>b</code>也不存在，尽管闭包中保存了<code>b</code>的引用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Y= outer();  <span class="hljs-comment">// outer() invoked the second time</span><br></code></pre></td></tr></table></figure><p>这时执行和<code>X()</code>一样的过程，并且创建全新的环境和变量…..</p><p>现在，让我们看看执行以下代码行时会发生什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">X(); <span class="hljs-comment">// X() invoked the first time</span><br>X(); <span class="hljs-comment">// X() invoked the second time</span><br>X(); <span class="hljs-comment">// X() invoked the third time</span><br><br>Y(); <span class="hljs-comment">// Y() invoked the first time</span><br></code></pre></td></tr></table></figure><p><strong>首次调用</strong></p><ol><li>创建变量<code>a=20</code></li><li><code>a</code>的值来自赋值语句，<code>b</code>的值来自闭包中保存的<code>b1</code>，<code>b=10</code></li><li><code>a++、b++</code>，自增</li><li><code>X()</code>完成执行，内部变量释放<br>然而，<code>b1</code>作为闭包保留，所以继续存在。</li></ol><p><strong>第二次调用时</strong></p><ol><li>再次创建变量<code>a=20</code></li><li>由于上一次执行<code>b++</code>后<code>b1</code>的值增加了，故此时的<code>b=11</code></li><li><code>a++、b++</code>，再次自增</li><li><code>X()</code>完成执行，内部变量释放<br>然而，<code>b1</code>继续作为闭包保留，所以继续存在。</li></ol><p><strong>第三次调用时</strong><br>同理，此时<code>b=12</code></p><p><strong>首次调用</strong> <code>Y（）</code> 时，</p><ol><li>再次创建变量<code>a=20</code></li><li><code>a</code>的值来自赋值语句，<code>b</code>的值来自闭包中保存的<code>b1</code>，<code>b=10</code></li><li><code>a++、b++</code>，自增</li><li><code>Y()</code>完成执行，内部变量释放<br>然而，<code>b1</code>作为闭包保留，所以继续存在。</li></ol><p>前面三次执行<code>X()</code>和最后一次执行<code>Y()</code>，区别在于不同的函数构成不同的闭包，是彼此独立的，不会相互影响</p><p>##自此就是关于闭包的初步了解,深入了解关注后续博文</p>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css常用布局-居中方法盒模型flexbox模型</title>
    <link href="/2020/07/04/css%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80-%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9B%92%E6%A8%A1%E5%9E%8Bflexbox%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/07/04/css%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80-%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9B%92%E6%A8%A1%E5%9E%8Bflexbox%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-css布局模型-md-png"><a href="#一-css布局模型-md-png" class="headerlink" title="一 css布局模型(.md+.png)"></a>一 css布局模型(.md+.png)</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p><img src="https://i.loli.net/2020/07/04/fCO56B17hjdSWMr.png" alt="盒子模型"></p><h4 id="1-display文档流显示"><a href="#1-display文档流显示" class="headerlink" title="1. display文档流显示"></a>1. display文档流显示</h4><ul><li><p>外部显示类型</p><ul><li><p>控制在文档流中的排版</p><ul><li>inline  block  run-in</li></ul></li></ul></li><li><p>内部显示类型</p><ul><li><p>控制子元素的排版</p><ul><li>flow layout  grid  flex   table</li></ul></li></ul></li><li><p>legacy双关键字</p><ul><li><p>inline-block </p><ul><li>文档流中(即外部)表现为inline内联, 自身为block</li></ul></li><li><p>inline-flex</p><ul><li><p>外部表现为inline ,子元素为flex</p></li><li><p>若是浮动或者为绝对定位,那么相当于flex</p></li></ul></li></ul></li></ul><h4 id="2-position定位"><a href="#2-position定位" class="headerlink" title="2. position定位"></a>2. position定位</h4><ul><li><p>定基点: 可以理解为元素的左上角的位置;</p><ul><li><p>默认属性: static, 由浏览器控制, 无法设置top\left\right\bottom等, 定基点就是html文档;</p></li><li><p>绝对定位属性: absolute, 相对上一级父元素进行定位,</p><ul><li>父元素不可以是static,这样会直接定位到html元素,所以在父元素要添加relative属性.</li><li>会脱离正常页面流,不会占用空间.</li></ul></li><li><p>绝对绝对定位: fixed ,相对与屏幕位置</p><ul><li>表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置</li><li>浮动在表面,不随页面滚动</li></ul></li><li><p>粘性定位: sticky 动态效果</p><ul><li>sticky生效的前提是，必须搭配top、bottom、left、right这四个属性一起使用，不能省略，否则等同于relative定位</li><li>应用场景有:堆叠照片\表头固定</li></ul></li></ul></li></ul><h4 id="3-float浮动"><a href="#3-float浮动" class="headerlink" title="3. float浮动"></a>3. float浮动</h4><ul><li><p>特点</p><ul><li><p>沿其父元素的左侧或右侧放置,并变成块元素</p><ul><li>除了flex\inlien-flex</li></ul></li><li><p>保持流动性</p><ul><li>与absolute相反</li></ul></li></ul></li><li><p>定位</p><ul><li><p>脱离文档流</p></li><li><p>遇到其他float则排列下去,自左向右,自上而下</p></li><li><p>清除定位</p><ul><li><p>clear: both</p><ul><li>用于其他元素排列在float的下方,而非重叠或者围绕的时候使用</li></ul></li><li><p>clearfixed.after</p><ul><li>消除iinline-block与float的影响, 常用于水平导航栏制作</li></ul></li></ul></li></ul></li></ul><h3 id="flexbox模型"><a href="#flexbox模型" class="headerlink" title="flexbox模型"></a>flexbox模型</h3><p><img src="https://i.loli.net/2020/07/04/XErchUsPaZ8vilm.png" alt="flexbox模型"></p><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><ul><li>灵活性</li><li>控制子元素的流动,自身是一个flex容器</li><li>规定了弹性元素如何伸长或缩短以适应flex容器中的可用空间</li></ul><h4 id="2-指定"><a href="#2-指定" class="headerlink" title="2. 指定"></a>2. 指定</h4><ul><li><p>行内</p><ul><li>inline-flex</li></ul></li><li><p>块级</p><ul><li>flex</li></ul></li></ul><h4 id="3-属性设置"><a href="#3-属性设置" class="headerlink" title="3. 属性设置"></a>3. 属性设置</h4><ul><li><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><ul><li><p>flex-direction</p><ul><li><p>决定项目排列方向</p><ul><li>row  行</li><li>column  列</li></ul></li></ul></li><li><p>flex-wrap</p><ul><li><p>设置换行方式</p><ul><li>nowarp</li><li>warp</li><li>warp-reverse</li></ul></li></ul></li><li><p>justify-content</p><ul><li><p>项目水平对齐方式</p><ul><li>center</li><li>space-between</li><li>space-around</li></ul></li></ul></li><li><p>align-items</p><ul><li><p>项目垂直对齐方式</p><ul><li>center</li><li>stretch</li><li>baseline</li><li>flex-start</li></ul></li></ul></li><li><p>align-content</p><ul><li><p>多轴线对齐</p><ul><li>若只有一条则不起作用</li></ul></li></ul></li></ul></li><li><h5 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h5><ul><li><p>order</p><ul><li><p>定义项目在容器中的排列位置，越小越靠前 </p><ul><li>默认为0</li></ul></li></ul></li><li><p>flex-grow</p><ul><li><p>项目的放大比例</p><ul><li><p>默认为0</p><ul><li>存在剩余空间也不放大</li></ul></li><li><p>为不同项目设置数值</p><ul><li>剩余空间分配按照数值比例划分</li></ul></li></ul></li></ul></li><li><p>flex-shrink</p><ul><li><p>与flex-grow相反，定义缩小比例</p><ul><li>默认为1</li><li>没有负值</li></ul></li></ul></li><li><p>flex-basis</p><ul><li>分配多余空间之前，项目占据的主轴空间</li></ul></li><li><p>align-self</p><ul><li>覆盖容器的flex-items，拥有自定义的对齐方式</li></ul></li></ul></li></ul><h3 id="gird网格模型-待更新"><a href="#gird网格模型-待更新" class="headerlink" title="gird网格模型 (待更新)"></a>gird网格模型 (待更新)</h3><h2 id="二-HTML元素"><a href="#二-HTML元素" class="headerlink" title="二 HTML元素"></a>二 HTML元素</h2><p><img src="https://i.loli.net/2020/07/04/2kZxyhJlpe4oQsP.png" alt="HTML元素"></p><h3 id="1-行内"><a href="#1-行内" class="headerlink" title="1. 行内"></a>1. 行内</h3><ul><li><p>占据形式</p><ul><li><p>对应标签边框为界限</p><ul><li>具有包裹性</li></ul></li></ul></li><li><p>包含内容</p><ul><li><p>文本数据+其他行内元素</p><ul><li>若强制包含块级元素,会被打撒为匿名块,块级元素嵌套在其中,不提倡使用,不符合页面结构</li></ul></li></ul></li><li><p>特点</p><ul><li><p>自左向右流动</p><ul><li>IFC</li></ul></li><li><p>不能设置宽高</p></li></ul></li><li><p>常见</p></li></ul><h3 id="2-块级"><a href="#2-块级" class="headerlink" title="2. 块级"></a>2. 块级</h3><ul><li><p>占据形式</p><ul><li>占据父元素的整个空间</li></ul></li><li><p>包含内容</p><ul><li>所有元素类型</li></ul></li><li><p>特点</p><ul><li><p>自上而下</p><ul><li>BFC</li></ul></li><li><p>每个块元素独立一行</p></li></ul></li><li><p>常见</p><ul><li>div  p ol  ul   h  form  table  section  aside  article  audio  video</li></ul></li></ul><h3 id="3-主要特点"><a href="#3-主要特点" class="headerlink" title="3. 主要特点"></a>3. 主要特点</h3><ul><li>实际上没有区分,可以相互转化</li><li>主要区别是占据空间的形式</li><li>都在文档流内流动</li></ul><h2 id="三-居中"><a href="#三-居中" class="headerlink" title="三 居中"></a>三 居中</h2><p><img src="https://i.loli.net/2020/07/04/UTLb37JgQHatVZc.png" alt="居中"></p><p>带红点的可以用于设置水平垂直居中, 其他属性也可以相互结合设置 , 较常用就是</p><p>​    <strong>①不知道宽高&amp;&amp;是否兼容设置</strong></p><p>​    <strong>②是否能用flex</strong></p><h3 id="1-水平居中"><a href="#1-水平居中" class="headerlink" title="1. 水平居中"></a><strong>1. 水平居中</strong></h3><ul><li><p>行内元素(inline)</p><ul><li><p> text-align:center</p></li><li><p>类型</p><ul><li>inline/inline-block/inline-table/inline/flex </li></ul></li></ul></li><li><p>单个块级元素(block)</p><ul><li><p> 父元素设置text-aligin:center; 子元素设置max/min-width+margin:auto;否则会被拉伸到父元素宽高;</p></li><li><p>position: absolute</p><ul><li>margin: 0 auto;</li></ul></li><li><p>flex</p><ul><li>justify-content:center</li></ul></li></ul></li><li><p>多个块级元素(修改默认的inline为其他):</p><ul><li>inline-block  inline-flex  flex  block……</li></ul></li></ul><h3 id="2-垂直居中"><a href="#2-垂直居中" class="headerlink" title="2. 垂直居中"></a>2. 垂直居中</h3><ul><li><p>行内</p><ul><li><p>设置 line-height = height</p><ul><li>文字的垂直居中</li></ul></li><li><p>vertical-algin</p></li></ul></li><li><p>块级</p><ul><li><p>知道宽高</p><ul><li><p>绝对定位</p><ul><li>margin-top=marigin-bottom=50%</li></ul></li><li><p>display: table-cell</p><ul><li>vertical-align: middle;</li></ul></li></ul></li><li><p>不知道宽高</p><ul><li><p>绝对定位</p><ul><li><p>top/left=50%;<br>transform: translate(-50%,-50%)</p></li><li><p>margin-auto</p><ul><li> top/left/bottom/right:0 </li></ul></li></ul></li><li><p>flex模型</p><ul><li><p>align-items: center;</p><ul><li>justify-content: center</li></ul></li></ul></li><li><p>盒子模型</p><ul><li>vertical-align: middle;</li></ul></li></ul></li></ul></li><li><p>table布局(待更)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise与jsonp</title>
    <link href="/2020/06/18/promise%E4%B8%8Ejsonp/"/>
    <url>/2020/06/18/promise%E4%B8%8Ejsonp/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Promise-A-MDN"><a href="#一-Promise-A-MDN" class="headerlink" title="一 Promise/A+MDN"></a>一 Promise/A+<sup><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a></sup></h2><h3 id="1-何为promise"><a href="#1-何为promise" class="headerlink" title="1. 何为promise:"></a>1. 何为promise:</h3><p>promise是一种<strong>解决方案</strong>,用于处理异步编程中回调问题,比传统的回调函数更加合理易用.</p><p>这里的回调问题主要是<strong>函数名不统一</strong>和**<a href="https://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ==&mid=2247484700&idx=1&sn=0a840596519263dd8baa1e4a0f265151&chksm=ec2b4880db5cc196a314f2b00eee6a070f06bfe76c78520dd1dfb1c580fd2854b5bea1e52b92&mpshare=1&scene=23&srcid=05018Hm3bknNtywEJv1Yn5T2#rd">回调地狱</a>**问题,例如在使用第三方库的ajax时,调用传统的回调函数,需要知道函数参数的名称,有的是succ,有的可以是done等等.所以需要统一的风格来共用一套解决方案,所以有了promise来处理这个问题;回调地狱是由于多重函数作为参数层层嵌套,最后造成可读性很差、代码量巨大、可维护性差等问题.</p><p>promise在语法上是一个<strong>对象</strong>,构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;...&#125; <span class="hljs-comment">/* executor */</span>  );<br></code></pre></td></tr></table></figure><p>promise对象包含:</p><ul><li><p>三种状态:</p><ul><li> pending(待定)</li><li> fulfill(完成)</li><li> rejected(失败)  </li></ul></li><li><p>两个函数参数:</p><ul><li>resolve</li><li>reject </li></ul><p>其中调用过程如下:<br>  <img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="调用过程"></p></li></ul><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建一个promise</span><br><span class="hljs-keyword">const</span> myFirstPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// ?做一些异步操作，最终会调用下面两者之一:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   resolve(someValue); // fulfilled</span><br><span class="hljs-comment">// ?或</span><br><span class="hljs-comment">//   reject(&quot;failure reason&quot;); // rejected</span><br>&#125;);<br><br><span class="hljs-comment">//让某个函数拥有promise功能</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAsyncFunction</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, url);<br>    xhr.onload = <span class="hljs-function">() =&gt;</span> resolve(xhr.responseText);<br>    xhr.onerror = <span class="hljs-function">() =&gt;</span> reject(xhr.statusText);<br>    xhr.send();<br>  &#125;);<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//例1:</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserId</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>        <span class="hljs-comment">//异步请求</span><br>        http.get(url, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>) </span>&#123;<br>            resolve(results.id)<br>        &#125;)<br>    &#125;)<br>&#125;<br><br>getUserId().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>&#123;<br>    <span class="hljs-comment">//一些处理</span><br>&#125;)<br><br><span class="hljs-comment">//例2:</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xxx</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>doyouwork();<br>        cosnt res;<br>        cosnt err;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(success)&#123;<br>            resolve().call(<span class="hljs-literal">undefined</span>,res)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            reject().call(<span class="hljs-literal">undefined</span>,err)<br>        &#125;<br>        &#125;)<br>    &#125;)<br>&#125;<br><br>xxx().then(succ(res),fail(err))  <span class="hljs-comment">///调用</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//简单原型结构</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-literal">null</span>,<br>        callbacks = [];  <span class="hljs-comment">//callbacks为数组，因为可能同时有很多个回调</span><br><br>    <span class="hljs-built_in">this</span>.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) </span>&#123;<br>        callbacks.push(onFulfilled);<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>        callbacks.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>            callback(value);<br>        &#125;);<br>    &#125;<br>    <br>    fn(resolve);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>getUserId返回的Promise对象通过then注册它成功的回调函数 </p></li><li><p>从数据结构的角度就是promise调用自身的then方法,向callbacks队列push进去一个函数对象, 实现入队操作</p></li></ul><h3 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法:"></a>3.成员方法:</h3><p><img src="https://i.loli.net/2020/06/18/tLHNSW6TqJz7Xdf.png" alt="image-20200618132622539"></p><p>​    </p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all(iterable)</code></a></p><p>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合</p><p>常见的应用场景有页面加载多个ajax数据回来以前，保持loading显示，或者加载失败后进行异步操作</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race(iterable)</code></a></p><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象</p><p>如Promise.race([p1, p2, p3]), 应用场景有超时机制</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject"><code>Promise.reject(reason)</code></a></p><p>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"><code>Promise.resolve(value)</code></a></p><p>返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。</p></li><li><p>Promise.prototype.then(onFulfilled[, onRejected])</p><p>当 Promise 变成接受状态（fulfilled）时调用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Function"><code>函数</code></a>。该函数有一个参数，即接受的最终结果（the fulfillment  value）。如果该参数不是函数，则会在内部被替换为 <code>(x) =&gt; x</code>，即原样返回 promise 最终结果的函数<br>当 Promise 变成拒绝状态（rejected）时调用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Function"><code>函数</code></a>。该函数有一个参数，即拒绝的原因（<code>rejection reason</code>）。 如果该参数不是函数，则会在内部被替换为一个 “Thrower” 函数 (it throws an error it received as argument)<br>当一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 完成（fulfilled）或者失败（rejected）时，返回函数将被异步调用（由当前的线程循环来调度完成）</p></li></ul><h3 id="4-来日补充"><a href="#4-来日补充" class="headerlink" title="4.来日补充"></a>4.来日补充</h3><h2 id="二-JSONP"><a href="#二-JSONP" class="headerlink" title="二 JSONP"></a>二 JSONP</h2><h3 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1.JSON"></a>1.JSON</h3><p>​    javascript是一种是一种具有函数优先的轻量级，解释型或即时编译型的编程语言脚本语言</p><p>​    json是一种数据格式化语言 </p><p>​    jsonp是一种JSON扩展，是一种JSON的使用格式</p><p>​    json是以键值对的形式进行对数据交换的支持，语法支持对象、数组、字符串、数值、null、Boolean，相比javacript少了symbol和undefined。</p><p>​    主要的用处在于交换数据，比如动态网页想要数据的写数据，发送请求后服务器把数据转换为json格式，客户端接受json并解析其中的文本内容以应用到网页上。</p><p>​    JSON<a href="https://www.json.org/json-zh.html">官网</a></p><h3 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2.JSONP"></a>2.JSONP</h3><p>​    <em>JSONP or “JSON with padding” is a JSON extension wherein a prefix is specified as an input argument of the call itself.</em></p><p>​    jsonp模式可以破除跨域同源限制进行第三方数据访问, 此外用其他标签通过添加<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">CORS</a>协议的请求头也可以实行跨域资源访问,只不过需要和后端协调</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>jsonp格式<br>parseRespone&#123;<span class="hljs-regexp">//</span>---&gt;这就是padding<br>​<span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-string">&quot;String&quot;</span><br><br>​<span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">233</span> <span class="hljs-regexp">//</span>---&gt;<span class="hljs-string">&quot;键&quot;</span>:值<br><br>&#125;<span class="hljs-regexp">//</span>---&gt;这也是padding<br></code></pre></td></tr></table></figure><p>​    JSONP使用json的使用模式：</p><ol><li><p>使用js标签</p><pre><code>由于js标签没有[跨域同源](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)的限制(即同协议、同端口、同主机)，使用\&lt;script&gt;标签，src指向需要请求的网址如：</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src= <span class="hljs-string">&quot;https://cn.bing.com/?scope=web/&quot;</span> &gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​    值的注意的是，<strong>jsonp只能用get方法，因为jsonp借助的是js动态标签，而动态标签只能用get</strong></p><ol start="2"><li><p>约定回调<br>响应方获取请求方提供的回调函数名，做相应的处理后返回JSON数据的封装，形如上面的中的jsonp格式</p></li><li><p>调用回调</p></li></ol><p>请求方获取json封装的服务器响应数据，并解析获取其中内容，调用回调函数后，加载到网页上</p></li></ol><p>至此jsonp完成,总结两点:</p><ul><li><p>JSONP是通过 script 标签加载数据的方式去获取数据当做 JS 代码来执行</p></li><li><p>提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。换句话说，JSONP 需要对应接口的后端的配合才能实现。</p></li></ul><p>完整示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//jquery的ajax封装</span><br>$.ajax(&#123;<br>url:<span class="hljs-string">&quot;www.exmaple.com/fuck&quot;</span>,<br>dataType: <span class="hljs-string">&quot;jsonp&quot;</span>,<br>success: <span class="hljs-function"><span class="hljs-title">fucntion</span>(<span class="hljs-params">response</span>)</span>&#123;<br>doyouwork()<br>&#125;,<br>fail: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(err)&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>​            </p><p>学习链接    : <a href="https://zhuanlan.zhihu.com/p/42377418">知乎</a>  <a href="https://es6.ruanyifeng.com/#docs/promise#Promise-%E7%9A%84%E5%90%AB%E4%B9%89">阮一峰</a>  <a href="https://promisesaplus.com/">promise/A+规范</a>  <a href="https://www.bilibili.com/video/BV1MJ41197Eu?p=2">Bilibili尚硅谷学习promise学习教程</a></p>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js原型链</title>
    <link href="/2020/03/23/js%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2020/03/23/js%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="原型链-link-MDN"><a href="#原型链-link-MDN" class="headerlink" title="原型链 link-MDN"></a><strong>原型链</strong> <sup><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">link-MDN</a></sup></h2><br><hr><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. <strong>概念</strong></h3><p>每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（prototype ）该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 null.</p><p><em>原型链</em>:    原型对象有着各种共用属性, 在访问属性过程中, 通过该对象和原型对象的层层搜索,直到尾端null的过程.<br><br></p><hr><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. <strong>继承</strong></h3><p>js的继承基于原型链, 对象本质上是一个动态的属性包, 继承属性与其他属性,没有区别.</p><p><strong>调用this时,this指向当前继承的对象.而非原型对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<br>  a: <span class="hljs-number">2</span>,<br>  m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(o.m()); <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 当调用 o.m 时，&#x27;this&#x27; 指向了 o.</span><br><br><span class="hljs-keyword">var</span> p = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-comment">// p是一个继承自 o 的对象</span><br><br>p.a = <span class="hljs-number">4</span>; <span class="hljs-comment">// 创建 p 的自身属性 &#x27;a&#x27;</span><br><span class="hljs-built_in">console</span>.log(p.m()); <span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 调用 p.m 时，&#x27;this&#x27; 指向了 p</span><br><span class="hljs-comment">// 又因为 p 继承了 o 的 m 函数</span><br><span class="hljs-comment">// 所以，此时的 &#x27;this.a&#x27; 即 p.a，就是 p 的自身属性 &#x27;a&#x27; </span><br><span class="hljs-comment">// from MDN</span><br></code></pre></td></tr></table></figure><br><hr><h3 id="3-prototype和-proto"><a href="#3-prototype和-proto" class="headerlink" title="3. prototype和__proto__"></a>3. <strong>prototype和__proto__</strong></h3><p><strong>prototype是函数的属性</strong><br>这个属性是一个指针，指向一个对象，这个对象的用途就是<strong>包含所有实例共享的属性和方法</strong>（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做<strong>constructor</strong>，这个属性包含了一个指针，指回原构造函数</p><p>**__proto__是对象的属性**<br>对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</p><p><small><a href="https://www.zhihu.com/question/34183746">detail 1</a></small></p><p><small><a href="https://www.zhihu.com/question/56770432/answer/315342130">detail 2</a></small></p><p><img src="https://pic1.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg" alt="zhihu"><br><br></p><hr><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. <strong>使用</strong></h3><p>假设创建一个新的对象 function doSomething() {}</p><ol><li><strong>添加属性</strong> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-built_in">console</span>.log( doSomething.prototype );<br></code></pre></td></tr></table></figure></li><li><strong>添加继承</strong> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>; <span class="hljs-comment">// add a property onto the prototype</span><br><span class="hljs-keyword">var</span> doSomeInstancing = <span class="hljs-keyword">new</span> doSomething();<br>doSomeInstancing.prop = <span class="hljs-string">&quot;some value&quot;</span>; <span class="hljs-comment">// add a property onto the object</span><br><span class="hljs-built_in">console</span>.log( doSomeInstancing );<br></code></pre></td></tr></table></figure></li><li><strong>打印出原型链</strong> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>prop: <span class="hljs-string">&quot;some value&quot;</span>,<br>__proto__: &#123;<br>    foo: <span class="hljs-string">&quot;bar&quot;</span>,<br>    <span class="hljs-title">constructor</span>: ƒ <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>),<br>    <span class="hljs-title">__proto__</span>: &#123;<br>        <span class="hljs-title">constructor</span>: ƒ <span class="hljs-title">Object</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">hasOwnProperty</span>: ƒ <span class="hljs-title">hasOwnProperty</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">isPrototypeOf</span>: ƒ <span class="hljs-title">isPrototypeOf</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">propertyIsEnumerable</span>: ƒ<br>        <span class="hljs-title">propertyIsEnumerable</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">toLocaleString</span>: ƒ <span class="hljs-title">toLocaleString</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">toString</span>: ƒ <span class="hljs-title">toString</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">valueOf</span>: ƒ <span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>即</p><p> <strong>doSomeInstancing.__ proto __ = doSomething.prototype</strong></p><p><strong>doSomeInstancing—&gt;doSoemthing.prototype—&gt;Object.prototype</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2020/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/03/14/fcHSC1Wkl9OVsay.jpg" alt="Inked一  数据结构概论_LI.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>木星疯人院</title>
    <link href="/2020/02/20/%E6%9C%A8%E6%98%9F%E7%96%AF%E4%BA%BA%E9%99%A2/"/>
    <url>/2020/02/20/%E6%9C%A8%E6%98%9F%E7%96%AF%E4%BA%BA%E9%99%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="木星疯人院"><a href="#木星疯人院" class="headerlink" title="木星疯人院"></a>木星疯人院</h2><p><em>这是一个荒诞的梦，似乎有点玄幻，但我应该记录下来。因为至今我还未曾做过一个如此记忆犹新的梦，某种至在莫种程度上，出乎真实。</em></p><p><img src="https://mixkit.imgix.net/art/419/419-square.png?w=200&h=441&q=80&auto=format,compress&q=80&dpr=1"></p><p>我又醒了，在不知名的灰白色房间里，床榻也是灰白的，朦胧的阳光透过灰白到发黄的窗帘晕染了我的视线。</p><p>今天又是一份试卷，我不知道为什么要做试卷，貌似和早餐一样，是我起床第一件要做的事情。也不多想，就是做完它，但也每次都记不起来试卷的内容是什么。</p><p>之后便出现一位少女，在我房间，也不知道她在做什么，我甚至没有看过她，但是，冥冥中就存在一样，我就是知道那是一位女性，而且不可触及，但是可以感知。</p><p>我继续呆在原地，好像有发生点什么。</p><p>不知怎么的，我站在一幢灰白相间的礼堂前，有着几十阶的阶梯，我在阶梯上，看着周围突兀的绿水青山，而且只有青绿的边界，没有山峦的细节，仿佛乐高玩具捏造的一般。堂前停放了一辆小型的厢式货车，有一位很健谈的司机，和我们很聊得来，哦，我们是指我和另外两个朋友，一个记得清是谁，一个就不得而知了。</p><p>我们聊了一会，我一位朋友爬上货车顶躺下休息。我们在等待，等待货车司机出货，大概聊天的内容也是关于这些吧。</p><p>好像就这样过了好几天，这样的“天”周期很短，至少不是24小时，也不会觉得无聊，甚至很期待货车司机什么时候去出货，至于出的是什么货，没有人关心，像是期待探险队临行前的兴奋。</p><p>后来没等到司机出货，等来了一群新人，素不相识，玩笑打闹，像是很有趣。</p><p>我自然是加入到他们一列，并走进了礼堂，说是礼堂，其实就是一间间空旷的教室，一直有着5点20下课的黄昏景色，很是怀旧，而且单调。</p><p>我们自然是呆不住，东走走，西走走，不知怎么的，总会遇到死路。</p><p>最后一次走动，我们遇到了一处木栅栏挡住了去路，前面是两位穿着警察制服的人在向路人打听消息。无路可去，我们便悻悻而归。</p><p>我再一次在灰白的房间醒来，这次试卷有了内容，几道单选，几道填空，还有一道问答。</p><p>这次有人在和我交流，是一个比我稍大的师兄（意义上的师兄，不特指），梦里无法发声，发声也是禁音的口型，他似乎在用思想和我交流，像是三体人一样。他正和我激动的介绍着一种新科技，将有机体与机械结合，目前已经实现了机械植物应用，将会进一步展开研究。</p><p>我很好奇，似乎梦里的除了好奇没有其他情绪。</p><p>我便继续填写试卷，试卷的大概内容就是关于这项技术的观点建议。</p><p>我把我的感受写了下去，这是一项不聪明的发明，并且告诫他们，不可在动物上使用，否则由灾难性的后果。</p><p>这时候潜意识里，我隐约觉得，这位男性和那位少女一样，和我在这里生活了很久，一直都在。</p><p>最后梦逐渐模糊，只有闪现的几个画面，大家都在逃命，赶往火箭航班。我站在礼堂外，遇到一位大学老师，寒暄后她便匆匆离开。</p><p>我站在原地，像是在登出。</p><p>后记：来自我的一个梦，梦里的事物大多在我的生活中找得到联系。不同以往的梦醒来就忘了，这次会有这么强烈的画面感，甚至有点连续和故事性，梦中的有机体与机械的技术，应用到了机械植物，礼堂和只有青绿色轮廓的山似乎在昭示着什么。而不可思议的是，一天的周期短，要乘坐火箭离开，这似乎不是在地球上。登出的操作让我想起了三体的那个三体人的脱水的游戏。而那对在灰白房间少年少女，我的感觉是物化的某种精神状态。</p><p>以上全部是我的梦，我基本真实的描述了下来，但太过真实，太过戏剧，不必较真，读者自斟。</p>]]></content>
    
    
    <categories>
      
      <category>南城六月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>梦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>display布局</title>
    <link href="/2020/02/19/display%E5%B8%83%E5%B1%80/"/>
    <url>/2020/02/19/display%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一-关于display"><a href="#一-关于display" class="headerlink" title="一 关于display"></a>一 关于display</h2><p>所有元素在网页上的存在形式都是长方体,而影响网页的布局的主要因素一方面是<a href="https://www.bukun.top/2020/02/11/%E5%AD%A6%E4%B9%A0%E9%80%9F%E8%AE%B0-html-ccs/#%E5%9D%97%E9%AB%98%E5%BA%A6-amp-amp-%E5%86%85%E8%81%94%E9%AB%98%E5%BA%A6">文档流</a>,一方面则是css控制的元素的表现形式display,其中常用的有:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline;        <span class="hljs-comment">/* Default of all elements, unless UA stylesheet overrides */</span><br>  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-comment">/* Characteristics of block, but sits on a line */</span><br>  <span class="hljs-attribute">display</span>: block;         <span class="hljs-comment">/* UA stylesheet makes things like &lt;div&gt; and &lt;section&gt; block */</span><br>  <span class="hljs-attribute">display</span>: run-in;        <span class="hljs-comment">/* Not particularly well supported or common */</span><br>  <span class="hljs-attribute">display</span>: none;          <span class="hljs-comment">/* Hide */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有元素默认的样式都是<strong>inline</strong>内联,而浏览器的用户代理脚本(<a href="https://stackoverflow.com/questions/12582624/what-is-user-agent-stylesheet">UA stylesheet</a>)会改变大部分的元素为<strong>block</strong>块</p><h2 id="二-概略MDN"><a href="#二-概略MDN" class="headerlink" title="二 概略MDN"></a>二 概略<sup><a href="https://developer.mozilla.org/en/CSS/display"><strong>MDN</strong></a><sup/></h2><h3 id="inline-内联"><a href="#inline-内联" class="headerlink" title="inline 内联"></a>inline 内联</h3><ul><li><p>元素的默认值,eg:  span em b…..</p></li><li><p>不会破坏文本的流动,以基线为准和其他元素保持在同一行内<img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2011/09/inline-element.png?w=346&ssl=1" alt="this"></p></li><li><p>使用margin和padding会在水平方向扩张但不会再垂直方向扩张,但不接受width height的值<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2011/09/inlinepadding.png?w=519&ssl=1" alt="css-tricks"></p></li></ul><h3 id="inline-block-内联块"><a href="#inline-block-内联块" class="headerlink" title="inline-block 内联块"></a>inline-block 内联块</h3><ul><li>基本与内联一致,但是不同的是有以下两点<ul><li>接受width height</li><li>水平和垂直方向的边距都会扩张<br><img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2011/09/inline-block.png?w=526&ssl=1" alt="css-tricks"></li></ul></li></ul><h3 id="block-块"><a href="#block-块" class="headerlink" title="block 块"></a>block 块</h3><ul><li>div\section\ul\p\h#….等会被浏览器设置为block显示</li><li>块级元素不会<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements">内联</a>,但是会跨过内联元素而被分割<br><img src="https://i2.wp.com/css-tricks.com/wp-content/uploads/2011/09/block.png?w=520&ssl=1" alt="css-tricks"></li></ul><h3 id="run-in-嵌入"><a href="#run-in-嵌入" class="headerlink" title="run-in 嵌入"></a>run-in 嵌入</h3><ul><li>火狐不支持</li><li>嵌入元素(如报纸首行前面的大字)<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2011/09/Run-in.png?resize=294,97" alt="css"></li></ul><h3 id="flex-弹性"><a href="#flex-弹性" class="headerlink" title="flex 弹性"></a><strong>flex 弹性</strong></h3><ul><li><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Flexbox Layout（弹性盒）（W3C 2017推荐模块）的目标是提供一种更有效的方式来布置，元素在一个容器中对齐和分配空间，即使大小未知或者是动态的（单词“ flex”的来由）。</p><p>flex布局的主要思想是<strong>使容器能够更改其项目的宽度/高度（和顺序）</strong>，以<strong>最好地填充</strong>可用空间（用于适应显示设备和屏幕尺寸）。Flex容器会将元素扩大以填充可用的可用空间，或收缩它们防止溢出。</p><p>与常规布局（<strong>基于垂直的块和基于水平的内联块</strong>）相比，<strong>flexbox布局与方向无关</strong>。尽管这些样式对于页面效果很好，但是它们缺乏灵活性来支持大型或复杂的应用程序（尤其是在方向更改，调整大小，拉伸，缩小等方面）。</p><p><em>Flexbox适合app和小规模布局，而<a href="#gird-%E7%BD%91%E6%A0%BC">Grid</a>布局则用于较大规模的布局</em></p></li><li><h4 id="图形知识"><a href="#图形知识" class="headerlink" title="图形知识"></a>图形知识</h4><p><img src="https://css-tricks.com/wp-content/uploads/2018/11/00-basic-terminology.svg" alt="basic"><br>main axis:  主轴<br>cross axis: 交叉[横]轴  </p></li><li><h4 id="基础与术语"><a href="#基础与术语" class="headerlink" title="基础与术语"></a>基础与术语</h4></li><li><h5 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h5><ol><li><p>display: flex //或者inline-flex,colum属性无效</p></li><li><p>flex-direction: row | row-reverse | column | column-reverse;</p><ul><li>row（默认值）：从左到右ltr；从右到左rtl</li><li>row-reverse：从右到左的ltr; 从左到右rtl</li><li>column：与row上至下相同</li><li>column-reverse：与row-reverse下至上相同</li><li><img src="https://css-tricks.com/wp-content/uploads/2018/10/flex-direction.svg" alt="img"></li></ul></li><li><p>flex-wrap: nowrap | wrap | wrap-reverse;<br> 以不同的缠绕方式排列,分别为<strong>一行||缠绕||反向缠绕</strong><br><img src="https://i.loli.net/2020/02/20/sPGW1ERuAlMeDfT.png" alt="批注 2020-02-20 114204.png"></p></li><li><p>flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;缩写</p></li><li><p>justify-content<br> 分配顺着父容器主轴的弹性元素之间及其周围的空间<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/justify-content.svg" alt="img"></p></li><li><p>align-items<br> justify在垂直方向的布局<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/align-items.svg" alt="csst"></p></li><li><p>align-content<br> 类似于将整体视为单个元素进行justify的排列<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/align-content.svg" alt="csst"></p></li></ol></li><li><h5 id="children元素的属性"><a href="#children元素的属性" class="headerlink" title="children元素的属性"></a>children元素的属性</h5><ol><li>order<br> 默认为零,按源代码的顺序排列元素,强制添加数字则可以排序<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/order.svg" alt="csst"></li><li>flex-grow<br> 设置分配比例,默认为1,平均分配||更换为2则改元素是其他元素的两倍(负值不可用)<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/flex-grow.svg" alt="csst"></li><li>flex-shrink<br> 设置缩小比例,与grow类似</li><li>flex-basis<br> 设置默认的获得扩充空间的比例,元素本身+其他空间,这里的其他空间会被分配给元素,和grow相关,添加grow的比例就会分配空间<br> <img src="https://www.w3.org/TR/css-flexbox-1/images/rel-vs-abs-flex.svg" alt="w3c"></li><li>flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]   简写</li><li>align-self<br> 对单个元素的对齐方式进行规定,用于覆盖align-items<br> 不支持float,clear,vertical-align</li></ol></li></ul><ul><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">完全使用手册和案例–来自css-tricks</a></li><li><a href="https://css-tricks.com/using-flexbox/">新旧flex一些差异[旧]</a></li></ul><h3 id="Gird-网格"><a href="#Gird-网格" class="headerlink" title="Gird 网格"></a>Gird 网格</h3><ul><li><a href="https://css-tricks.com/snippets/css/complete-guide-grid/">待整理</a></li></ul><h3 id="none-隐藏"><a href="#none-隐藏" class="headerlink" title="none 隐藏"></a>none 隐藏</h3><ul><li>值得注意的是,隐藏后的元素还是存在与DOM中</li></ul><h3 id="table-values-表格"><a href="#table-values-表格" class="headerlink" title="table-values 表格"></a>table-values 表格</h3><ul><li>与标签table的功能类似,但是不同的是有更多的语义表达</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<span class="hljs-comment">/*&lt;table&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-cell;<span class="hljs-comment">/*&lt;td&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-column;<span class="hljs-comment">/* &lt;col&gt; */</span><br>  <span class="hljs-attribute">display</span>: table-colgroup;<span class="hljs-comment">/* &lt;colgroup&gt; */</span><br>  <span class="hljs-attribute">display</span>: table-header-group;<span class="hljs-comment">/*&lt;thead&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-row-group;<span class="hljs-comment">/*&lt;tbody&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-footer-group;<span class="hljs-comment">/*&lt;tfoot&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-row;<span class="hljs-comment">/*&lt;tr&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-caption;<span class="hljs-comment">/*&lt;caption&gt;*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用方式模仿表格</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;div style=&quot;display: table;&quot;&gt;<br>  &lt;div style=&quot;display: table-row;&quot;&gt;<br>    &lt;div style=&quot;display: table-cell;&quot;&gt;<br>     It&#x27;s suck!wubu labu dabuda!<br>    &lt;/<span class="hljs-selector-tag">div</span>&gt;<br>  &lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新山鬼</title>
    <link href="/2020/02/09/%E6%96%B0%E5%B1%B1%E9%AC%BC/"/>
    <url>/2020/02/09/%E6%96%B0%E5%B1%B1%E9%AC%BC/</url>
    
    <content type="html"><![CDATA[<p>​    南方的小村以南横亘着一条河，一直往北绵延潜伏在一座山里。山里有座古刹，传说是夏禹治水建造，曰：”山鬼庙“，为众人祈福，保风护雨。千百年来，当地风调雨顺，因而庙宇备受人们敬仰，香火鼎盛。<br>但不料乾坤不定，天灾来临，大水如猛禽掠食，缺粮，死人，饥荒肆虐，哀鸿遍野。<br>​    众人散去，庙宇冷清，僧侣还俗，门可罗雀。<br>​    只留下一位俊俏的小僧，立半柱清香于佛前，守净庭而闲扫落叶，于堂前诵读般若，或打禅静坐，日复一日。<br>常有嫠妇前来添油，不至于小僧多日无餐。但此般妇人多是觊觎小僧貌美，盼其还俗，作家中劳力。她们觉得，似乎在很早以前庙里就一直有一位年轻俊俏的小和尚，但也说不出眼前这位有何异样。<br>小僧只是默而不语，收下香火，道阿弥，赠与瑶草。<br>​    庭前半亩见方之地植有瑶草，盖小僧灾后所植，遗人治病。朝出而作，夕落而服，凡数年，不见小僧色老。<br>​    一日，旦为朝云，暮为行雨。子夜，狂风大作，小僧于佛前击昏惰。有一女子夺门，身披薄裳，腰束女萝，发梢蜷蜷，全身湿透，赤足，肤白，貌美。<br>​    “小施主可否借宿一宿？”女子小声问到。<br>​    小僧不语，击昏惰。<br>​    “公子？”女子来到堂前。<br>​    小僧不语，击昏惰。<br>​    那女子与小僧相对而坐，彻夜无言，直至天明。<br>​    小僧放下木槌，起身出去。<br>​    旦起朝云，僧人落泪：<br>​    “姐姐为何耽误小君修行？”<br>​    说罢，便化云而去。再看那庙中，已无女子，庭前瑶草尽数枯萎。<br>​    日后风雨平顺，众人归来，却再无人问津山中古庙。游人踏青，问：“闻山中有灵庙，此为何山何庙？”<br>其中人语云：“巫山，山鬼庙”。</p><h6 id="作者注：此文灵感来自屈原《楚辞·九歌》及《水经注》先秦神话仙女瑶姬。人物有山鬼（女子），云中君（小僧）。两者皆为风雨之神。本问切入主题描绘青年男女的爱感情心理，结合个人经历想法而作。寓意，人人皆为修行，彼此在风雨之中各有相容，各有距离，相遇便是一场风雨，相识相知便是相对而坐，而耽搁修行便是无言对坐的感慨。千人千面，任君解读"><a href="#作者注：此文灵感来自屈原《楚辞·九歌》及《水经注》先秦神话仙女瑶姬。人物有山鬼（女子），云中君（小僧）。两者皆为风雨之神。本问切入主题描绘青年男女的爱感情心理，结合个人经历想法而作。寓意，人人皆为修行，彼此在风雨之中各有相容，各有距离，相遇便是一场风雨，相识相知便是相对而坐，而耽搁修行便是无言对坐的感慨。千人千面，任君解读" class="headerlink" title="作者注：此文灵感来自屈原《楚辞·九歌》及《水经注》先秦神话仙女瑶姬。人物有山鬼（女子），云中君（小僧）。两者皆为风雨之神。本问切入主题描绘青年男女的爱感情心理，结合个人经历想法而作。寓意，人人皆为修行，彼此在风雨之中各有相容，各有距离，相遇便是一场风雨，相识相知便是相对而坐，而耽搁修行便是无言对坐的感慨。千人千面，任君解读"></a>作者注：此文灵感来自屈原《楚辞·九歌》及《水经注》先秦神话仙女瑶姬。人物有山鬼（女子），云中君（小僧）。两者皆为风雨之神。本问切入主题描绘青年男女的爱感情心理，结合个人经历想法而作。寓意，人人皆为修行，彼此在风雨之中各有相容，各有距离，相遇便是一场风雨，相识相知便是相对而坐，而耽搁修行便是无言对坐的感慨。千人千面，任君解读</h6><p>ps: 本文获冰心青少年文学奖大学组一等奖. 🎉🎉🎉</p><p>作者: 博主本人</p>]]></content>
    
    
    <categories>
      
      <category>南城六月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
