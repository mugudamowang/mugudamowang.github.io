<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript闭包简易指南</title>
    <link href="/2020/07/24/JavaScript%E9%97%AD%E5%8C%85%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97(%E7%BF%BB%E8%AF%91)/"/>
    <url>/2020/07/24/JavaScript%E9%97%AD%E5%8C%85%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97(%E7%BF%BB%E8%AF%91)/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript闭包简易指南-翻译"><a href="#JavaScript闭包简易指南-翻译" class="headerlink" title="JavaScript闭包简易指南(翻译)"></a>JavaScript闭包简易指南(翻译)</h1><p>在学习闭包过程之中，发现了medium中一篇比较好理解的外国博客。为方便学习交流，在下初略翻译搬运，并在自己的理解上进行修改和添加了自己的内容.</p><p>本文适合初步了解闭包，只从作用域和函数执行过程两个角度简易解释闭包<br>深入认识闭包还要从设计模式、应用场景、浏览器垃圾回收机制和词法作用域（待更新）</p><p><a href="https://medium.com/@prashantramnyc/javascript-closures-simplified-d0d23fa06ba4">原文连接</a></p><hr><p>javascript中的闭包是让许多开发者头疼的东西。在下面的文章中，我将清楚地解释何为闭包，并使用简单的范例来阐述要点。</p><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是 JavaScript 中的一项<strong>功能</strong>，其中<strong>内部函数</strong>可以访问<strong>外部（封闭）函数的变量</strong><br>就是函数和函数变量所处作用域的混合</p><p>即形成 <strong>范围链</strong>(<em>即作用域链，个人认为范围链更容易理解</em>，)。</p><p>闭包有三个范围链：</p><ul><li>它有权访问自己的范围(作用域)——在其大括号<code>&#123;&#125;</code>之间定义的变量</li><li>它有权访问外部函数的变量</li><li>它可以访问全局变量</li></ul><p>小白看到这些行话有可能不太理解</p><p>(<em>可自行查阅MDN中的js作用域、变量等知识点</em>)</p><h2 id="为什么要用闭包"><a href="#为什么要用闭包" class="headerlink" title="为什么要用闭包?"></a><strong>为什么要用闭包?</strong></h2><h3 id="简单的闭包例子"><a href="#简单的闭包例子" class="headerlink" title="简单的闭包例子"></a>简单的闭包例子</h3><p>看看一个简单闭包的范例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;   <br>   <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(a+b);<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有两个功能：</p><ul><li>具有变量<code> b</code>的外部函数<code>outer</code>，返回值是<code>inner</code></li><li>具有变量<code>a</code>的内部函数<code>inner</code>，在其内部可以访问<code>outer</code>的变量<code>b</code></li></ul><p><code>b</code>的作用范围被限制在函数<code>outer</code>内，<code>a</code>则被限制在<code>inner</code>中</p><p>现在调用函数，并赋值存储到变量上。</p><p>然后，第二次调用同样的过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;   <br>   <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;     <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(a+b);<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>&#125;<br><span class="hljs-keyword">var</span> X = outer(); <span class="hljs-comment">//outer() invoked the first time</span><br><span class="hljs-keyword">var</span> Y = outer(); <span class="hljs-comment">//outer() invoked the second time</span><br></code></pre></td></tr></table></figure><p>一行一行来康康<code>outer</code>函数第一次执行过程</p><ol><li><p>变量<code>b</code>被创建，它的作用域是<code>outer</code>之内，此时赋值<code>b=10</code></p></li><li><p>这一行开始是函数声明</p></li><li><p><code>inner</code>结束后是<code>return inner</code>，发现返回的是个函数，此时返回整个<code>inner</code>函数体<br>[注意<code>return</code>并不会执行<code>inner</code>函数，只有<code>inner</code>被调用才执行]</p></li><li><p>被返回的内容被存储在变量<code>x</code>中， 即 <code>x = </code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">console</span>.log(a + b);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数执行结束， <code>outer</code>作用域内的所有变量都被释放，不再存在</p></li></ol><p>这个过程中第四步最为重要，要注意<strong>一旦函数结束执行，函数范围内的任何变量都将消失</strong></p><p><code>函数执行时间 === 函数内变量生存周期</code></p><p>既然这样， 当尝试调用<code>X</code>时，<code>outer</code>函数的执行已经结束，只在执行时存在变量<code>b</code>此时已经被释放，那么属于<code>outer</code>的变量<code>b</code>在<code>inner</code>中的<code>console.log(a + b)</code>就会报错， b应该是<code>undefined</code></p><p>当函数第二次执行，此时赋值给变量Y，重复上述过程<br>……</p><p>第二次执行的重点是，这时的变量都是全新的，同样符合:<br><code>函数执行时间 === 函数内变量生存周期</code></p><p>现在回到代码，看看<code>X</code>和<code>Y</code>，<code>outer</code>函数执行后都返回同样的函数给变量<code>X</code>和<code>Y</code>，那么<code>X</code>和<code>Y</code>也理所当然是函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//按f12在控制台中打印x和y的类型:</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(X)); <span class="hljs-comment">//X is of type function</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(Y)); <span class="hljs-comment">//Y is of type function</span><br></code></pre></td></tr></table></figure><p>执行<code>X</code>和<code>Y</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;     <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(a+b);<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>&#125;<br><span class="hljs-keyword">var</span> X = outer(); <br><span class="hljs-keyword">var</span> Y = outer(); <br><span class="hljs-comment">//end of outer() function executions</span><br>X(); <span class="hljs-comment">// X() invoked the first time</span><br>X(); <span class="hljs-comment">// X() invoked the second time</span><br>X(); <span class="hljs-comment">// X() invoked the third time</span><br><br>Y(); <span class="hljs-comment">// Y() invoked the first time</span><br></code></pre></td></tr></table></figure><p>不难看出实际上我们都在执行<code>inner</code></p><p>来一步一步看看执行过程:</p><ol><li>创建变量<code>a = 20</code></li><li>JavaScript 现在尝试执行 。这里是事情变得有趣的地方。JavaScript 知道存在变量<code>a</code>， 因为第一步刚刚创建它。<br>但是，根据变量生命周期，属于<code>outer</code>的<code>b</code>不再存在。<br><code>outer</code>函数早在我们调用<code>inner</code>之前就完成了执行，因此函数范围内的任何变量都不再存在</li><li>……</li></ol><p>*上面这个例子就是是要说明需要闭包的原因: <strong>只有函数跑起来的时候变量才存在</strong>，那么怎么使用哪些其他本应消失的变量*?</p><p>为了解决这个矛盾，JavaScript设计出闭包.</p><h2 id="闭-包"><a href="#闭-包" class="headerlink" title="闭 包"></a>闭 包</h2><p>上例阐述了:<br><code>inner</code>函数可以访问已经结束生命周期的<code>outer</code>函数中的变量<code>b</code></p><p>用一句话来解释闭包:<br>一个函数在已封闭的函数执行时，保存并且能够访问范围链内的局部变量(即已封闭的函数的变量)，此时产生的就是闭包</p><p>用轮子哥的话说(站在闭包的角度):<br><img src="https://i.loli.net/2020/07/24/MPqcvyFNmLp8b3Z.png" alt="img"></p><p>在我们的示例中，<code>inner</code>函数保留了执行<code>outer</code>函数时的值，并继续保留(称为’’封闭’’)</p><p>注意有个重点是:<br><strong>inner只有在使用到了外部的局部变量时，范围链内才出现闭包</strong></p><p>现在再理解以下范围链，注意到这条链中确实有变量<code>b</code>的值，因为<code>b</code>在<code>outer</code>函数执行时将闭包的值封闭在闭包内。</p><p>所以语句<code>console.log(a + b)</code>才能够正确执行，得到想要结果</p><p>您可以通过向上述示例添加以下代码行来验证这一点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;    <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(a+b);<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>&#125;<br><span class="hljs-keyword">var</span> X = outer(); <span class="hljs-built_in">console</span>.dir(X); <br><span class="hljs-comment">//use console.dir() instead of console.log()</span><br></code></pre></td></tr></table></figure><p>通过控制台打印出函数执行路径:<br><img src="https://i.loli.net/2020/07/24/h2zE1GfuCFnv7DM.png" alt="1_WB0SdempUbLxhVLMS2DvDA"></p><p>可以看到变量 <code>b=10</code> 保留在 <code>inner</code>中的<br>Scopes链→<br>    →Closure闭包<br>    →b : 10</p><p>现在回到文章开头提出的范围链并和闭包关联起来:</p><ul><li><p>它有权访问自己的范围(作用域)——变量<code>a</code></p></li><li><p>它有权访问外部函数的变量——变量<code>b</code></p></li><li><p>它可以访问全局变量</p></li></ul><h2 id="闭包的实际使用"><a href="#闭包的实际使用" class="headerlink" title="闭包的实际使用"></a>闭包的实际使用</h2><p>使用闭包的核心要点，让我们通过添加三行代码展示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> c = <span class="hljs-number">100</span>;   <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;    <br>         <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a= &quot;</span> + a + <span class="hljs-string">&quot; b= &quot;</span> + b);            a++;<br>         b++;<br>    &#125;<br>   <span class="hljs-keyword">return</span> inner;<br>    <br>&#125;<br><span class="hljs-keyword">var</span> X = outer();  <span class="hljs-comment">// outer() invoked the first time</span><br><span class="hljs-keyword">var</span> Y = outer();  <span class="hljs-comment">// outer() invoked the second time</span><br><span class="hljs-comment">//end of outer() function executions</span><br>X(); <span class="hljs-comment">// X() invoked the first time</span><br>X(); <span class="hljs-comment">// X() invoked the second time</span><br>X(); <span class="hljs-comment">// X() invoked the third time</span><br><br>Y(); <span class="hljs-comment">// Y() invoked the first time</span><br></code></pre></td></tr></table></figure><p>运行这段代码，将在在控制台中看到以下输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=20 <span class="hljs-attribute">b</span>=10<br><span class="hljs-attribute">a</span>=20 <span class="hljs-attribute">b</span>=11<br><span class="hljs-attribute">a</span>=20 <span class="hljs-attribute">b</span>=12<br><span class="hljs-attribute">a</span>=20 <span class="hljs-attribute">b</span>=10<br></code></pre></td></tr></table></figure><p>让我们逐步检查此代码，看看到底发生了什么，并看到闭包的过程！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> X = outer();  <span class="hljs-comment">// outer() invoked the first time</span><br></code></pre></td></tr></table></figure><p><strong>初始调用函数outer</strong><br>这是调用的是<code>outer</code>，执行以下步骤：</p><ol><li>变量<code>b=10</code>， <code>c=100</code>被创建，作为参考命名为<code>b1，c1</code></li><li><code>inner</code>函数被返回并且复制给变量<code>X</code><br>此时变量<code>b</code>被使用到，因此被<code>inner</code>封闭到它的范围链内，即产生了闭包，这个闭包包含一个变量<code>b : 10</code></li><li><code>outer</code>函数完成执行，并且它的所有变量都不再存在。<br>变量<code>b</code>也不存在，尽管闭包中保存了<code>b</code>的引用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Y= outer();  <span class="hljs-comment">// outer() invoked the second time</span><br></code></pre></td></tr></table></figure><p>这时执行和<code>X()</code>一样的过程，并且创建全新的环境和变量…..</p><p>现在，让我们看看执行以下代码行时会发生什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">X(); <span class="hljs-comment">// X() invoked the first time</span><br>X(); <span class="hljs-comment">// X() invoked the second time</span><br>X(); <span class="hljs-comment">// X() invoked the third time</span><br><br>Y(); <span class="hljs-comment">// Y() invoked the first time</span><br></code></pre></td></tr></table></figure><p><strong>首次调用</strong></p><ol><li>创建变量<code>a=20</code></li><li><code>a</code>的值来自赋值语句，<code>b</code>的值来自闭包中保存的<code>b1</code>，<code>b=10</code></li><li><code>a++、b++</code>，自增</li><li><code>X()</code>完成执行，内部变量释放<br>然而，<code>b1</code>作为闭包保留，所以继续存在。</li></ol><p><strong>第二次调用时</strong></p><ol><li>再次创建变量<code>a=20</code></li><li>由于上一次执行<code>b++</code>后<code>b1</code>的值增加了，故此时的<code>b=11</code></li><li><code>a++、b++</code>，再次自增</li><li><code>X()</code>完成执行，内部变量释放<br>然而，<code>b1</code>继续作为闭包保留，所以继续存在。</li></ol><p><strong>第三次调用时</strong><br>同理，此时<code>b=12</code></p><p><strong>首次调用</strong> <code>Y（）</code> 时，</p><ol><li>再次创建变量<code>a=20</code></li><li><code>a</code>的值来自赋值语句，<code>b</code>的值来自闭包中保存的<code>b1</code>，<code>b=10</code></li><li><code>a++、b++</code>，自增</li><li><code>Y()</code>完成执行，内部变量释放<br>然而，<code>b1</code>作为闭包保留，所以继续存在。</li></ol><p>前面三次执行<code>X()</code>和最后一次执行<code>Y()</code>，区别在于不同的函数构成不同的闭包，是彼此独立的，不会相互影响</p><p>##自此就是关于闭包的初步了解,深入了解关注后续博文</p>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css常用布局-居中方法盒模型flexbox模型</title>
    <link href="/2020/07/04/css%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80-%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9B%92%E6%A8%A1%E5%9E%8Bflexbox%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/07/04/css%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80-%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9B%92%E6%A8%A1%E5%9E%8Bflexbox%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一-css布局模型-md-png"><a href="#一-css布局模型-md-png" class="headerlink" title="一 css布局模型(.md+.png)"></a>一 css布局模型(.md+.png)</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p><img src="https://i.loli.net/2020/07/04/fCO56B17hjdSWMr.png" alt="盒子模型"></p><h4 id="1-display文档流显示"><a href="#1-display文档流显示" class="headerlink" title="1. display文档流显示"></a>1. display文档流显示</h4><ul><li><p>外部显示类型</p><ul><li><p>控制在文档流中的排版</p><ul><li>inline  block  run-in</li></ul></li></ul></li><li><p>内部显示类型</p><ul><li><p>控制子元素的排版</p><ul><li>flow layout  grid  flex   table</li></ul></li></ul></li><li><p>legacy双关键字</p><ul><li><p>inline-block </p><ul><li>文档流中(即外部)表现为inline内联, 自身为block</li></ul></li><li><p>inline-flex</p><ul><li><p>外部表现为inline ,子元素为flex</p></li><li><p>若是浮动或者为绝对定位,那么相当于flex</p></li></ul></li></ul></li></ul><h4 id="2-position定位"><a href="#2-position定位" class="headerlink" title="2. position定位"></a>2. position定位</h4><ul><li><p>定基点: 可以理解为元素的左上角的位置;</p><ul><li><p>默认属性: static, 由浏览器控制, 无法设置top\left\right\bottom等, 定基点就是html文档;</p></li><li><p>绝对定位属性: absolute, 相对上一级父元素进行定位,</p><ul><li>父元素不可以是static,这样会直接定位到html元素,所以在父元素要添加relative属性.</li><li>会脱离正常页面流,不会占用空间.</li></ul></li><li><p>绝对绝对定位: fixed ,相对与屏幕位置</p><ul><li>表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置</li><li>浮动在表面,不随页面滚动</li></ul></li><li><p>粘性定位: sticky 动态效果</p><ul><li>sticky生效的前提是，必须搭配top、bottom、left、right这四个属性一起使用，不能省略，否则等同于relative定位</li><li>应用场景有:堆叠照片\表头固定</li></ul></li></ul></li></ul><h4 id="3-float浮动"><a href="#3-float浮动" class="headerlink" title="3. float浮动"></a>3. float浮动</h4><ul><li><p>特点</p><ul><li><p>沿其父元素的左侧或右侧放置,并变成块元素</p><ul><li>除了flex\inlien-flex</li></ul></li><li><p>保持流动性</p><ul><li>与absolute相反</li></ul></li></ul></li><li><p>定位</p><ul><li><p>脱离文档流</p></li><li><p>遇到其他float则排列下去,自左向右,自上而下</p></li><li><p>清除定位</p><ul><li><p>clear: both</p><ul><li>用于其他元素排列在float的下方,而非重叠或者围绕的时候使用</li></ul></li><li><p>clearfixed.after</p><ul><li>消除iinline-block与float的影响, 常用于水平导航栏制作</li></ul></li></ul></li></ul></li></ul><h3 id="flexbox模型"><a href="#flexbox模型" class="headerlink" title="flexbox模型"></a>flexbox模型</h3><p><img src="https://i.loli.net/2020/07/04/XErchUsPaZ8vilm.png" alt="flexbox模型"></p><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><ul><li>灵活性</li><li>控制子元素的流动,自身是一个flex容器</li><li>规定了弹性元素如何伸长或缩短以适应flex容器中的可用空间</li></ul><h4 id="2-指定"><a href="#2-指定" class="headerlink" title="2. 指定"></a>2. 指定</h4><ul><li><p>行内</p><ul><li>inline-flex</li></ul></li><li><p>块级</p><ul><li>flex</li></ul></li></ul><h4 id="3-属性设置"><a href="#3-属性设置" class="headerlink" title="3. 属性设置"></a>3. 属性设置</h4><ul><li><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><ul><li><p>flex-direction</p><ul><li><p>决定项目排列方向</p><ul><li>row  行</li><li>column  列</li></ul></li></ul></li><li><p>flex-wrap</p><ul><li><p>设置换行方式</p><ul><li>nowarp</li><li>warp</li><li>warp-reverse</li></ul></li></ul></li><li><p>justify-content</p><ul><li><p>项目水平对齐方式</p><ul><li>center</li><li>space-between</li><li>space-around</li></ul></li></ul></li><li><p>align-items</p><ul><li><p>项目垂直对齐方式</p><ul><li>center</li><li>stretch</li><li>baseline</li><li>flex-start</li></ul></li></ul></li><li><p>align-content</p><ul><li><p>多轴线对齐</p><ul><li>若只有一条则不起作用</li></ul></li></ul></li></ul></li><li><h5 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h5><ul><li><p>order</p><ul><li><p>定义项目在容器中的排列位置，越小越靠前 </p><ul><li>默认为0</li></ul></li></ul></li><li><p>flex-grow</p><ul><li><p>项目的放大比例</p><ul><li><p>默认为0</p><ul><li>存在剩余空间也不放大</li></ul></li><li><p>为不同项目设置数值</p><ul><li>剩余空间分配按照数值比例划分</li></ul></li></ul></li></ul></li><li><p>flex-shrink</p><ul><li><p>与flex-grow相反，定义缩小比例</p><ul><li>默认为1</li><li>没有负值</li></ul></li></ul></li><li><p>flex-basis</p><ul><li>分配多余空间之前，项目占据的主轴空间</li></ul></li><li><p>align-self</p><ul><li>覆盖容器的flex-items，拥有自定义的对齐方式</li></ul></li></ul></li></ul><h3 id="gird网格模型-待更新"><a href="#gird网格模型-待更新" class="headerlink" title="gird网格模型 (待更新)"></a>gird网格模型 (待更新)</h3><h2 id="二-HTML元素"><a href="#二-HTML元素" class="headerlink" title="二 HTML元素"></a>二 HTML元素</h2><p><img src="https://i.loli.net/2020/07/04/2kZxyhJlpe4oQsP.png" alt="HTML元素"></p><h3 id="1-行内"><a href="#1-行内" class="headerlink" title="1. 行内"></a>1. 行内</h3><ul><li><p>占据形式</p><ul><li><p>对应标签边框为界限</p><ul><li>具有包裹性</li></ul></li></ul></li><li><p>包含内容</p><ul><li><p>文本数据+其他行内元素</p><ul><li>若强制包含块级元素,会被打撒为匿名块,块级元素嵌套在其中,不提倡使用,不符合页面结构</li></ul></li></ul></li><li><p>特点</p><ul><li><p>自左向右流动</p><ul><li>IFC</li></ul></li><li><p>不能设置宽高</p></li></ul></li><li><p>常见</p></li></ul><h3 id="2-块级"><a href="#2-块级" class="headerlink" title="2. 块级"></a>2. 块级</h3><ul><li><p>占据形式</p><ul><li>占据父元素的整个空间</li></ul></li><li><p>包含内容</p><ul><li>所有元素类型</li></ul></li><li><p>特点</p><ul><li><p>自上而下</p><ul><li>BFC</li></ul></li><li><p>每个块元素独立一行</p></li></ul></li><li><p>常见</p><ul><li>div  p ol  ul   h  form  table  section  aside  article  audio  video</li></ul></li></ul><h3 id="3-主要特点"><a href="#3-主要特点" class="headerlink" title="3. 主要特点"></a>3. 主要特点</h3><ul><li>实际上没有区分,可以相互转化</li><li>主要区别是占据空间的形式</li><li>都在文档流内流动</li></ul><h2 id="三-居中"><a href="#三-居中" class="headerlink" title="三 居中"></a>三 居中</h2><p><img src="https://i.loli.net/2020/07/04/UTLb37JgQHatVZc.png" alt="居中"></p><p>带红点的可以用于设置水平垂直居中, 其他属性也可以相互结合设置 , 较常用就是</p><p>​    <strong>①不知道宽高&amp;&amp;是否兼容设置</strong></p><p>​    <strong>②是否能用flex</strong></p><h3 id="1-水平居中"><a href="#1-水平居中" class="headerlink" title="1. 水平居中"></a><strong>1. 水平居中</strong></h3><ul><li><p>行内元素(inline)</p><ul><li><p> text-align:center</p></li><li><p>类型</p><ul><li>inline/inline-block/inline-table/inline/flex </li></ul></li></ul></li><li><p>单个块级元素(block)</p><ul><li><p> 父元素设置text-aligin:center; 子元素设置max/min-width+margin:auto;否则会被拉伸到父元素宽高;</p></li><li><p>position: absolute</p><ul><li>margin: 0 auto;</li></ul></li><li><p>flex</p><ul><li>justify-content:center</li></ul></li></ul></li><li><p>多个块级元素(修改默认的inline为其他):</p><ul><li>inline-block  inline-flex  flex  block……</li></ul></li></ul><h3 id="2-垂直居中"><a href="#2-垂直居中" class="headerlink" title="2. 垂直居中"></a>2. 垂直居中</h3><ul><li><p>行内</p><ul><li><p>设置 line-height = height</p><ul><li>文字的垂直居中</li></ul></li><li><p>vertical-algin</p></li></ul></li><li><p>块级</p><ul><li><p>知道宽高</p><ul><li><p>绝对定位</p><ul><li>margin-top=marigin-bottom=50%</li></ul></li><li><p>display: table-cell</p><ul><li>vertical-align: middle;</li></ul></li></ul></li><li><p>不知道宽高</p><ul><li><p>绝对定位</p><ul><li><p>top/left=50%;<br>transform: translate(-50%,-50%)</p></li><li><p>margin-auto</p><ul><li> top/left/bottom/right:0 </li></ul></li></ul></li><li><p>flex模型</p><ul><li><p>align-items: center;</p><ul><li>justify-content: center</li></ul></li></ul></li><li><p>盒子模型</p><ul><li>vertical-align: middle;</li></ul></li></ul></li></ul></li><li><p>table布局(待更)</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise与jsonp</title>
    <link href="/2020/06/18/promise%E4%B8%8Ejsonp/"/>
    <url>/2020/06/18/promise%E4%B8%8Ejsonp/</url>
    
    <content type="html"><![CDATA[<h2 id="一-Promise-A-MDN"><a href="#一-Promise-A-MDN" class="headerlink" title="一 Promise/A+MDN"></a>一 Promise/A+<sup><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a></sup></h2><h3 id="1-何为promise"><a href="#1-何为promise" class="headerlink" title="1. 何为promise:"></a>1. 何为promise:</h3><p>promise是一种<strong>解决方案</strong>,用于处理异步编程中回调问题,比传统的回调函数更加合理易用.</p><p>这里的回调问题主要是<strong>函数名不统一</strong>和**<a href="https://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ==&mid=2247484700&idx=1&sn=0a840596519263dd8baa1e4a0f265151&chksm=ec2b4880db5cc196a314f2b00eee6a070f06bfe76c78520dd1dfb1c580fd2854b5bea1e52b92&mpshare=1&scene=23&srcid=05018Hm3bknNtywEJv1Yn5T2#rd">回调地狱</a>**问题,例如在使用第三方库的ajax时,调用传统的回调函数,需要知道函数参数的名称,有的是succ,有的可以是done等等.所以需要统一的风格来共用一套解决方案,所以有了promise来处理这个问题;回调地狱是由于多重函数作为参数层层嵌套,最后造成可读性很差、代码量巨大、可维护性差等问题.</p><p>promise在语法上是一个<strong>对象</strong>,构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;...&#125; <span class="hljs-comment">/* executor */</span>  );<br></code></pre></td></tr></table></figure><p>promise对象包含:</p><ul><li><p>三种状态:</p><ul><li> pending(待定)</li><li> fulfill(完成)</li><li> rejected(失败)  </li></ul></li><li><p>两个函数参数:</p><ul><li>resolve</li><li>reject </li></ul><p>其中调用过程如下:<br>  <img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="调用过程"></p></li></ul><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建一个promise</span><br><span class="hljs-keyword">const</span> myFirstPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// ?做一些异步操作，最终会调用下面两者之一:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   resolve(someValue); // fulfilled</span><br><span class="hljs-comment">// ?或</span><br><span class="hljs-comment">//   reject(&quot;failure reason&quot;); // rejected</span><br>&#125;);<br><br><span class="hljs-comment">//让某个函数拥有promise功能</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAsyncFunction</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, url);<br>    xhr.onload = <span class="hljs-function">() =&gt;</span> resolve(xhr.responseText);<br>    xhr.onerror = <span class="hljs-function">() =&gt;</span> reject(xhr.statusText);<br>    xhr.send();<br>  &#125;);<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//例1:</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserId</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>        <span class="hljs-comment">//异步请求</span><br>        http.get(url, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>) </span>&#123;<br>            resolve(results.id)<br>        &#125;)<br>    &#125;)<br>&#125;<br><br>getUserId().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>&#123;<br>    <span class="hljs-comment">//一些处理</span><br>&#125;)<br><br><span class="hljs-comment">//例2:</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xxx</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>doyouwork();<br>        cosnt res;<br>        cosnt err;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(success)&#123;<br>            resolve().call(<span class="hljs-literal">undefined</span>,res)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            reject().call(<span class="hljs-literal">undefined</span>,err)<br>        &#125;<br>        &#125;)<br>    &#125;)<br>&#125;<br><br>xxx().then(succ(res),fail(err))  <span class="hljs-comment">///调用</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//简单原型结构</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-literal">null</span>,<br>        callbacks = [];  <span class="hljs-comment">//callbacks为数组，因为可能同时有很多个回调</span><br><br>    <span class="hljs-built_in">this</span>.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled</span>) </span>&#123;<br>        callbacks.push(onFulfilled);<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>        callbacks.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>            callback(value);<br>        &#125;);<br>    &#125;<br>    <br>    fn(resolve);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>getUserId返回的Promise对象通过then注册它成功的回调函数 </p></li><li><p>从数据结构的角度就是promise调用自身的then方法,向callbacks队列push进去一个函数对象, 实现入队操作</p></li></ul><h3 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法:"></a>3.成员方法:</h3><p><img src="https://i.loli.net/2020/06/18/tLHNSW6TqJz7Xdf.png" alt="image-20200618132622539"></p><p>​    </p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all(iterable)</code></a></p><p>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合</p><p>常见的应用场景有页面加载多个ajax数据回来以前，保持loading显示，或者加载失败后进行异步操作</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race(iterable)</code></a></p><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象</p><p>如Promise.race([p1, p2, p3]), 应用场景有超时机制</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject"><code>Promise.reject(reason)</code></a></p><p>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"><code>Promise.resolve(value)</code></a></p><p>返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。</p></li><li><p>Promise.prototype.then(onFulfilled[, onRejected])</p><p>当 Promise 变成接受状态（fulfilled）时调用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Function"><code>函数</code></a>。该函数有一个参数，即接受的最终结果（the fulfillment  value）。如果该参数不是函数，则会在内部被替换为 <code>(x) =&gt; x</code>，即原样返回 promise 最终结果的函数<br>当 Promise 变成拒绝状态（rejected）时调用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Function"><code>函数</code></a>。该函数有一个参数，即拒绝的原因（<code>rejection reason</code>）。 如果该参数不是函数，则会在内部被替换为一个 “Thrower” 函数 (it throws an error it received as argument)<br>当一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> 完成（fulfilled）或者失败（rejected）时，返回函数将被异步调用（由当前的线程循环来调度完成）</p></li></ul><h3 id="4-来日补充"><a href="#4-来日补充" class="headerlink" title="4.来日补充"></a>4.来日补充</h3><h2 id="二-JSONP"><a href="#二-JSONP" class="headerlink" title="二 JSONP"></a>二 JSONP</h2><h3 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1.JSON"></a>1.JSON</h3><p>​    javascript是一种是一种具有函数优先的轻量级，解释型或即时编译型的编程语言脚本语言</p><p>​    json是一种数据格式化语言 </p><p>​    jsonp是一种JSON扩展，是一种JSON的使用格式</p><p>​    json是以键值对的形式进行对数据交换的支持，语法支持对象、数组、字符串、数值、null、Boolean，相比javacript少了symbol和undefined。</p><p>​    主要的用处在于交换数据，比如动态网页想要数据的写数据，发送请求后服务器把数据转换为json格式，客户端接受json并解析其中的文本内容以应用到网页上。</p><p>​    JSON<a href="https://www.json.org/json-zh.html">官网</a></p><h3 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2.JSONP"></a>2.JSONP</h3><p>​    <em>JSONP or “JSON with padding” is a JSON extension wherein a prefix is specified as an input argument of the call itself.</em></p><p>​    jsonp模式可以破除跨域同源限制进行第三方数据访问, 此外用其他标签通过添加<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">CORS</a>协议的请求头也可以实行跨域资源访问,只不过需要和后端协调</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>jsonp格式<br>parseRespone&#123;<span class="hljs-regexp">//</span>---&gt;这就是padding<br>​<span class="hljs-string">&quot;key1&quot;</span> : <span class="hljs-string">&quot;String&quot;</span><br><br>​<span class="hljs-string">&quot;key2&quot;</span> : <span class="hljs-number">233</span> <span class="hljs-regexp">//</span>---&gt;<span class="hljs-string">&quot;键&quot;</span>:值<br><br>&#125;<span class="hljs-regexp">//</span>---&gt;这也是padding<br></code></pre></td></tr></table></figure><p>​    JSONP使用json的使用模式：</p><ol><li><p>使用js标签</p><pre><code>由于js标签没有[跨域同源](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)的限制(即同协议、同端口、同主机)，使用\&lt;script&gt;标签，src指向需要请求的网址如：</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src= <span class="hljs-string">&quot;https://cn.bing.com/?scope=web/&quot;</span> &gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​    值的注意的是，<strong>jsonp只能用get方法，因为jsonp借助的是js动态标签，而动态标签只能用get</strong></p><ol start="2"><li><p>约定回调<br>响应方获取请求方提供的回调函数名，做相应的处理后返回JSON数据的封装，形如上面的中的jsonp格式</p></li><li><p>调用回调</p></li></ol><p>请求方获取json封装的服务器响应数据，并解析获取其中内容，调用回调函数后，加载到网页上</p></li></ol><p>至此jsonp完成,总结两点:</p><ul><li><p>JSONP是通过 script 标签加载数据的方式去获取数据当做 JS 代码来执行</p></li><li><p>提前在页面上声明一个函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。换句话说，JSONP 需要对应接口的后端的配合才能实现。</p></li></ul><p>完整示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//jquery的ajax封装</span><br>$.ajax(&#123;<br>url:<span class="hljs-string">&quot;www.exmaple.com/fuck&quot;</span>,<br>dataType: <span class="hljs-string">&quot;jsonp&quot;</span>,<br>success: <span class="hljs-function"><span class="hljs-title">fucntion</span>(<span class="hljs-params">response</span>)</span>&#123;<br>doyouwork()<br>&#125;,<br>fail: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(err)&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>​            </p><p>学习链接    : <a href="https://zhuanlan.zhihu.com/p/42377418">知乎</a>  <a href="https://es6.ruanyifeng.com/#docs/promise#Promise-%E7%9A%84%E5%90%AB%E4%B9%89">阮一峰</a>  <a href="https://promisesaplus.com/">promise/A+规范</a>  <a href="https://www.bilibili.com/video/BV1MJ41197Eu?p=2">Bilibili尚硅谷学习promise学习教程</a></p>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js原型链</title>
    <link href="/2020/03/23/js%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2020/03/23/js%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="原型链-link-MDN"><a href="#原型链-link-MDN" class="headerlink" title="原型链 link-MDN"></a><strong>原型链</strong> <sup><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">link-MDN</a></sup></h2><br><hr><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. <strong>概念</strong></h3><p>每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（prototype ）该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 null.</p><p><em>原型链</em>:    原型对象有着各种共用属性, 在访问属性过程中, 通过该对象和原型对象的层层搜索,直到尾端null的过程.<br><br></p><hr><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. <strong>继承</strong></h3><p>js的继承基于原型链, 对象本质上是一个动态的属性包, 继承属性与其他属性,没有区别.</p><p><strong>调用this时,this指向当前继承的对象.而非原型对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;<br>  a: <span class="hljs-number">2</span>,<br>  m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(o.m()); <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 当调用 o.m 时，&#x27;this&#x27; 指向了 o.</span><br><br><span class="hljs-keyword">var</span> p = <span class="hljs-built_in">Object</span>.create(o);<br><span class="hljs-comment">// p是一个继承自 o 的对象</span><br><br>p.a = <span class="hljs-number">4</span>; <span class="hljs-comment">// 创建 p 的自身属性 &#x27;a&#x27;</span><br><span class="hljs-built_in">console</span>.log(p.m()); <span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 调用 p.m 时，&#x27;this&#x27; 指向了 p</span><br><span class="hljs-comment">// 又因为 p 继承了 o 的 m 函数</span><br><span class="hljs-comment">// 所以，此时的 &#x27;this.a&#x27; 即 p.a，就是 p 的自身属性 &#x27;a&#x27; </span><br><span class="hljs-comment">// from MDN</span><br></code></pre></td></tr></table></figure><br><hr><h3 id="3-prototype和-proto"><a href="#3-prototype和-proto" class="headerlink" title="3. prototype和__proto__"></a>3. <strong>prototype和__proto__</strong></h3><p><strong>prototype是函数的属性</strong><br>这个属性是一个指针，指向一个对象，这个对象的用途就是<strong>包含所有实例共享的属性和方法</strong>（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做<strong>constructor</strong>，这个属性包含了一个指针，指回原构造函数</p><p>**__proto__是对象的属性**<br>对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</p><p><small><a href="https://www.zhihu.com/question/34183746">detail 1</a></small></p><p><small><a href="https://www.zhihu.com/question/56770432/answer/315342130">detail 2</a></small></p><p><img src="https://pic1.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg" alt="zhihu"><br><br></p><hr><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. <strong>使用</strong></h3><p>假设创建一个新的对象 function doSomething() {}</p><ol><li><strong>添加属性</strong> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-built_in">console</span>.log( doSomething.prototype );<br></code></pre></td></tr></table></figure></li><li><strong>添加继承</strong> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>doSomething.prototype.foo = <span class="hljs-string">&quot;bar&quot;</span>; <span class="hljs-comment">// add a property onto the prototype</span><br><span class="hljs-keyword">var</span> doSomeInstancing = <span class="hljs-keyword">new</span> doSomething();<br>doSomeInstancing.prop = <span class="hljs-string">&quot;some value&quot;</span>; <span class="hljs-comment">// add a property onto the object</span><br><span class="hljs-built_in">console</span>.log( doSomeInstancing );<br></code></pre></td></tr></table></figure></li><li><strong>打印出原型链</strong> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>prop: <span class="hljs-string">&quot;some value&quot;</span>,<br>__proto__: &#123;<br>    foo: <span class="hljs-string">&quot;bar&quot;</span>,<br>    <span class="hljs-title">constructor</span>: ƒ <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>),<br>    <span class="hljs-title">__proto__</span>: &#123;<br>        <span class="hljs-title">constructor</span>: ƒ <span class="hljs-title">Object</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">hasOwnProperty</span>: ƒ <span class="hljs-title">hasOwnProperty</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">isPrototypeOf</span>: ƒ <span class="hljs-title">isPrototypeOf</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">propertyIsEnumerable</span>: ƒ<br>        <span class="hljs-title">propertyIsEnumerable</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">toLocaleString</span>: ƒ <span class="hljs-title">toLocaleString</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">toString</span>: ƒ <span class="hljs-title">toString</span>(<span class="hljs-params"></span>),<br>        <span class="hljs-title">valueOf</span>: ƒ <span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>即</p><p> <strong>doSomeInstancing.__ proto __ = doSomething.prototype</strong></p><p><strong>doSomeInstancing—&gt;doSoemthing.prototype—&gt;Object.prototype</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构概论导图</title>
    <link href="/2020/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/03/14/fcHSC1Wkl9OVsay.jpg" alt="Inked一  数据结构概论_LI.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端二向箔-HTML</title>
    <link href="/2020/03/09/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HTML/"/>
    <url>/2020/03/09/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF-HTML/</url>
    
    <content type="html"><![CDATA[<h2 id="绪论-系统化前端知识复盘"><a href="#绪论-系统化前端知识复盘" class="headerlink" title="绪论 系统化前端知识复盘"></a>绪论 系统化前端知识复盘</h2><h3 id="我的疑惑"><a href="#我的疑惑" class="headerlink" title="我的疑惑"></a>我的疑惑</h3><p>本人接触编程到学习前端知识, 估摸已有近一年多时间, 在这个过程中遇到了一些常见的问题:</p><ul><li>知识碎片化, 即使学习了大量的知识, 也有进行一些实战操作, 但很多时候知识系统一片混乱</li><li>即使使用了一些管理工具, 如onenote\博客\notion等, 仍然觉得自身整理的内容缺乏条理和价值</li><li>难以坚持, 在进行了约3-4个月的博客记录后, 之后频率降低, 有学习抵触心理</li><li>前景的思考, 前端的价值何在, 如何提升自身核心竞争力, 以及职业生涯成长规划如何. 相比之下, 后端较多情况下就是业务核心, 而前端大多是附属增值手段.</li></ul><h3 id="思考原因"><a href="#思考原因" class="headerlink" title="思考原因"></a>思考原因</h3><p>很多问题无法回避, 这里面主要是入门后的迷茫感和价值取向. 众口纷云的”35岁危机”绝不是空穴来风. 这种双重的疑问很容易造成对自身学习能力和目的的怀疑. 我是否真的适合这行当? 我是否真该选择做前端?</p><p>很大程度上几个疑惑是相互关联的, 主要是因为反馈结果不良, 造成热情低能状态, 进而没有很好地组织知识框架. 或者组织了知识框架, 缺乏规律性\科学的复盘计划, 也会得不偿失. 这有许多原因, 如个人网站曝光不够\自身文章质量不佳\缺乏自己的提炼思考, 为了记录而记录.</p><h3 id="前端价值何在"><a href="#前端价值何在" class="headerlink" title="前端价值何在?"></a>前端价值何在?</h3><p>本文不是吹毛求疵, 更不是贬低前端价值.</p><p>确实, 在我所认知的编程行业中, 前端即使脱离的<strong>机械性\大量</strong>的基础操作, 近年来也有优秀的<strong>工程化项目</strong>发展壮大, 但似乎许多东西还是拿来做着以前一样的事情, 只不过是换了种方式表达. 那似乎前端无法摆脱自身的枷锁, <strong>向更高价值区间跃进</strong>. 特别是在分工明确的团队中, 美工\UI将用户体验基本完成, 而前端的价值似乎又被瓜分, 在其中只做一个效率中间件. 而不管在大厂还是小厂, 这种局面似乎普遍存在, 望求解.</p><p>这种想法一定程度上受限于我个人的知识和经验, 前端发展势不可挡, 而且它还很年轻, 潜力还有许多可以发掘, 但这些质疑也应当被每个学习前端的深思过. 前端的价值何在? <strong>个人所见, 于商业上, 高效\多端可靠\用户交互做到完美符合用户需求; 于技术上, 改变信息的传播, 以极具创造力的方式来为生活\生产带来质的变化</strong>. 前端首先是个工程师, 然后是个前端, 说到底, 对于俗人来说, 这全都是谋生的手段. 放大来讲, 更不应该局限于前端这个标签, 应去了解学习编程世界的全貌, 纵横捭阖才观得大势. 要向着高层框架的角度去思考前端移动展示和用户交互而前进, 而非做个<strong>思想的螺丝钉</strong>, 一心一意切页面.</p><h3 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h3><p>选择在博客平台进行表达, 进行复盘, 精进与勉励. 计划在1~2个月内完成前端复盘工作, 说是复盘, 更多的是自我检查和自省. </p><p>复盘主要解决的是知识点由散乱到连线成面的过程. 做好自身的管理, 协调时间提升自己, 形成系统化的前端知识体系, 建立学习的方法论. 不在被动式地焦虑疑惑. </p><p>复盘也将更多的在每一门技术的价值\背景\设计思想的角度出发. 而不是简单的用法记录, 那样无异于无意义学习. (而且还灌水)</p><p>诸君共勉.</p><h2 id="01-学习路线RoadMap"><a href="#01-学习路线RoadMap" class="headerlink" title="01 学习路线RoadMap"></a>01 学习路线RoadMap</h2><p><a href="https://juejin.cn/post/6924858439587889165">00 绪论 系统化前端知识复盘</a></p><h3 id="我学前端的核心思想"><a href="#我学前端的核心思想" class="headerlink" title="我学前端的核心思想"></a>我学前端的核心思想</h3><p>大多数大学是不会将前后端之类具体职业设立为专业的, 即使开设有前端相关课程, 较多都是以jsp和一些接近过时的网页开发知识. 原因有二: <strong>①高校培养人才目的不是为了岗位培养</strong>, 而是为了综合性的指标, 个人成长, 社会价值和行业发展. <strong>②前端变化太快了</strong>, 大学老师旨在授课于知识的方法论和处世之道, 而非培训班, 更与教学育人的属性有出入. </p><p>即使如此, 有个很矛盾的地方, 就是前端的顶尖人才匮乏, 这个职业很年轻, 潜力无限, 需要有着高水平和创新力的人才. 奈何于大学专业授课的属性相悖, <strong>导致没有系统的教学方案</strong>人才培养计划, 大多数都是依靠自学, 或者培训班. 缺乏系统的知识体系就难以维系大量的知识积累和实践. 结果就会出现前端过热, 却仍然没有多大突破性的发展.</p><p>所以, 要立志高远, 格物致知. 不要陷入重复性\无意义劳动的陷阱, 这样只会固步自封. <strong>保持持续学习的能力</strong>是任何一个人在行业中精进的核心. 也不要局限于岗位之上, 吃饭固然重要, 如何利用自身资源和优势, 去实现更高的目标, 而非办公室一隅孤芳自赏. </p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>建立系统的前端知识结构体系, 锻炼工程师素养</li><li>完善学习编程的方法论</li><li>技术的核心思想的理解</li><li>学习交流, 自检</li></ul><h3 id="组织形式"><a href="#组织形式" class="headerlink" title="组织形式"></a>组织形式</h3><p>常见网络知识博客组织形式都是以某个技术热点为展开, 这样有个弊端, 较难从语言\数据结构\性能架构的层次去理解知识. 而且缺乏相关的逻辑关联, 导致即使学了很多, 也看懂了, 间歇性地遗忘地问题, 显然这种形式对构建知识体系并不友好.</p><p>web前端核心就是Javascript语言, 对于语言, 可以以语言地学习规律去串联各个技术点. 特别是Javascript, 可以从<strong>语言的结构, 运行环境和执行</strong>三部分去组织, 向下引伸可以是基础语法\内存\数据结构-堆, 栈\事件等. </p><p>对于一些<strong>html</strong>和<strong>css</strong>, 此类标记语言和样式语言, 组织形式尤为重要. html要考察其<strong>合理性\语义化\分类归纳</strong>, css一方面是美学素养, 对于前端工程师, 更重要的是<strong>高性能的架构</strong>, 可靠的兼容性\交互效果, 所以要着重理解其设计模式. </p><p>之后是一些常见API和计算机网络知识, 这一部分主要是考察应用和理解. 其中, 浏览器模型需要了解其实现原理, 并与API, 网络技术相互关联, 深化架构体系</p><p>最后才是一些关键技术问题和热点, 如前端工程化, 前端框架探讨, 以及面试问题的收录.</p><h3 id="RoadMap-来自github"><a href="#RoadMap-来自github" class="headerlink" title="RoadMap-来自github"></a>RoadMap-来自github</h3><ul><li>一份来之gayhub的高星前端技术路线 <a href="https://github.com/kamranahmedse/developer-roadmap">link↗</a></li><li>查看我的notion整理页面: <a href="https://www.notion.so/Web-developer-in-2020-446c2641a2a44cf5894832bda363e364">link↗</a></li><li>可能有更新, 可以上GitHub查看最新版</li><li>可以作为参考, 进行遍历学习或者复盘, 当然要结合我之前的组织形式进行构建体系, 这些远远不够, 需要更加主动地收集知识管理的方法论\模型, 整理出自己的架构.</li><li>一边写一边尝试知识的组织信息</li></ul><p><img src="https://i.loli.net/2021/02/12/bezEol7fgCnGYyj.png" alt="road"></p><h2 id="02-HTML语义化"><a href="#02-HTML语义化" class="headerlink" title="02 HTML语义化"></a>02 HTML语义化</h2><p>语义化标签应该是HTML5基本的规范要求, 对于良好的web语义化, 不单是说表义上理解的标签语义, 语义化最大的好处是<strong>方便机器识别</strong>. 特别是在一些<strong>视障人群</strong>和<strong>阅读模式</strong>的适配. 良好的语义化更有利于网页<strong>SEO</strong>, 增加曝光. </p><p>这些应该是初级入门时了解到的语义化的相关程度. 而对于深入一些, 应该对于语义化有业务场景结合的思考.</p><p>当然, 个人认为, 要真正理解并运用语义化, 还要对<strong>HTML内容分类</strong>有较深入了解, MDN已有优质<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Content_categories">wiki🔗</a></p><h3 id="不求一丝不苟-只需因地制宜"><a href="#不求一丝不苟-只需因地制宜" class="headerlink" title="不求一丝不苟, 只需因地制宜"></a>不求一丝不苟, 只需因地制宜</h3><p>刚开始入门的时候, 语义化的实施要么一丝不苟地严格使用, 要么零散分布, 想起来的时候就用上. 但一段时间后大多不会在语义上有太多讲究, 用的最多地就是<code>header</code> <code>section</code> <code>nav</code> 等常见标签. </p><p>事实上, 花费时间过渡琢磨和不讲究都不是语义化的良好实践. 在应用层面上, 也许**<code>div</code>和<code>span</code>加上class完全可以完成业务需求**, 而且对于性能表现也不会有太大影响. 语义化更多的用处是在<strong>wiki页面</strong>上, 这类网页有良好的阅读目的, 因此语义化较为重要.</p><p>反而错误使用语义化标签会导致负面影响, 如常见的, <code>ul</code> <code>ol</code>, 前者表并列, 后者表顺位. 还有用<strong>div和span去交错包裹形成混乱的嵌套</strong>, 对浏览器阅读识别很不友好.</p><p>因此, 对于语义的使用, 是需要确保可以合理的组织运用, <strong>保持语义化结构不被平铺的div和span打断.</strong></p><p>接下来分析一下如何实践语义化规范.</p><h3 id="基于wiki类型的语义化例子"><a href="#基于wiki类型的语义化例子" class="headerlink" title="基于wiki类型的语义化例子"></a>基于wiki类型的语义化例子</h3><p>此类网页语义化内容并不多, 无非是围绕<strong>文章内容呈现</strong>而定制地几个标签结构.<br>一个典型地wiki详情页的<code>body</code>应该有以下结构, 常用于博客, 新闻界面类型的网页应用.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来以<a href="https://developer.mozilla.org/zh-CN/docs/Learn">MDN↗</a>为例, 结合上述Sample, 对于语义化进行阐述.</p><p><img src="https://i.loli.net/2021/02/11/c1LEJjhxzI6GCPZ.png" alt="image-20210211232520414"></p><p>👆非实际页面结构, 辅助理解</p><h3 id="如何优雅地使用"><a href="#如何优雅地使用" class="headerlink" title="如何优雅地使用"></a>如何优雅地使用</h3><p>整体可以拆分为结构元素和内嵌元素, wiki页面追求SEO, 传播目的性强, 需要组织成良好的语义化网页.</p><h4 id="1-结构元素"><a href="#1-结构元素" class="headerlink" title="1. 结构元素"></a>1. 结构元素</h4><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>网页头部, 展示介绍性的内容, 辅助工具等, 也常用于包裹标题组合.</p><p><img src="https://i.loli.net/2021/02/11/HebvGRTuWPFB2Cw.png" alt="image-20210211230200731"></p><h4 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h4><p>侧边栏, 工具类, 导航, 于页面内容独立且不影响主体</p><p><img src="https://i.loli.net/2021/02/11/l4LHI7TdXBPJkuE.png" alt="image-20210211233102497"></p><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>main表示的内容要求独立性, 且具有分段意义, 因此, 对于网页上独立的内容需要用main概括.</p><h4 id="article"><a href="#article" class="headerlink" title="article"></a>article</h4><p>article相比main强调的是媒体内容, 特别是新闻传播中有独立意义的文章.</p><p><img src="https://i.loli.net/2021/02/11/BxRNUTnoqAwrZtk.png" alt="image-20210211234457735"></p><h4 id="section"><a href="#section" class="headerlink" title="section"></a>section</h4><p>section并没用较明确的语义, 一般就作组成部分. 可以用作</p><ul><li>文档大纲概要, 一般包括一个标题和文字描述</li><li>文章内容分段</li></ul><p><img src="https://i.loli.net/2021/02/12/EuMIFTP8vg7VpJn.png" alt="image-20210212121628861"></p><h4 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h4><p><code>footer</code>分为<code>article</code>的和<code>body</code>的, 主要职能就是展示脚注, 引用目录, 附加信息, 地址邮件等.</p><p><img src="https://i.loli.net/2021/02/12/7ZPoc5ApFXy3zRb.png" alt="image-20210212121917346"></p><h4 id="2-内嵌元素"><a href="#2-内嵌元素" class="headerlink" title="2. 内嵌元素"></a>2. 内嵌元素</h4><ul><li><p><code>h1</code>~`h6 <code>\ </code>hgroup`: 一般h1\h2再用hgrop包裹就是一个基本的标题组, 还可在html中生成目录结构</p></li><li><p><code>nav</code> –导航标签, 用于链接页面形成目录索引, 内部有ol\ul和li.</p></li><li><p><code>strong</code>和<code>em</code>, <code>b</code>和<code>i</code> 的异同: </p><ul><li><p>b、i属于<strong>修饰类标签</strong>；strong、em属于<strong>内容类标签</strong></p></li><li><p>b、strong标签表现为<strong>加粗</strong>；em、i表现为<strong>倾斜</strong></p></li><li><p>strong、em表<strong>强调</strong>；strong比em语气更强烈；strong在<strong>页面</strong>上的强调，而em是更多在<strong>语义</strong>上强调</p></li><li><p>strong和em真正做到了结构与样式分离，而b、i没有做到结构与样式的分离</p></li><li><p>在搜索引擎优化strong和em比b和i重要的多。</p></li></ul></li><li><p><code>figure</code> –图表, 和<code>figcaption</code> 描述一起使用, 用于描述独立的图片与文字组合.</p></li><li><p><code>cite</code> –引用, 在论文中常见.</p></li><li><p><code>mark</code> –高亮, 读者角度, 高亮文本.</p></li><li><p><code>detail </code> –挂件, 形式为下拉菜单. 和summary提供概要.</p></li><li><p><code>time</code> –时间, 可以让机器阅读更加方便.</p></li><li><p><code>pre</code> –预定义格式输出, 不改变排版, ( 输出字面量标签要更换为转义符, 如’&lt;’👉&amp;lt ).</p><ul><li><code>samp</code>–代码示例, 一般用于表示程序输出信息\非代码的程序部分.</li><li><code>code</code> –源代码.</li></ul></li></ul><p>可见, 结构元素以一条完整的主线, 串联起各个部分, W3C专家倡导的文字排版应用在web上, 体现web作为信息传播的重要途径和文字排版学问的广博.</p><p>跑偏了, 我们要把握基本的结构, 再适当地使用内嵌其中的语义化标签, 形成良好的规范和结构.</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>语义化是相对简单地一个知识点, 本文不是在介绍各个标签的详细用法, 也并没有列出全部语义标签. 旨在标出个人认为形成语义化规范的<strong>重要且基础</strong>的部分. </p><p>是否要严格执行语义化, 要根据具体的业务需求, 对于<strong>传播目的性强\团队协作\规范严谨</strong>的一类网页可以加强这方面的实施, 对于<strong>功能目的性强的\业务效率优先</strong>的网页则可以简化. 语义化本身有些争议, 这是文本标记语言的特性决定的, 不像其他编程语言一样需要非常严谨的逻辑和规则.</p><p>当然, 文中提到的只是wiki文章中典型的语义化要求, 也可以抽象出通用的语义化要求:</p><ul><li><strong>文本层面语义化</strong></li><li><strong>结构层次的语义化</strong></li></ul><p>本文提供语义化思想的方法论, 届时更新更加深入的语义化优化方案.</p><h2 id="03-HTML元数据和链接"><a href="#03-HTML元数据和链接" class="headerlink" title="03 HTML元数据和链接"></a>03 HTML元数据和链接</h2><p>html元数据即在<code>head</code>标签中的部分, 主要是描述了网页的一些重要的信息和媒体链接.  大多情况下是提供给浏览器爬虫和机器阅读的.  链接作为网页的互联的基石, 在head中链接有<code>link</code>和<code>script</code>两种形式. </p><p>本文归纳常见的元数据和链接的重要知识.</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><ul><li><p>head</p><p>head本身没有意义, 只提供保存容器, 是Document的元数据集合. 不会在页面上显示, 且只有一个title和base.</p></li><li><p>title</p><p>网页html文档标题, 而非网页内容标题( h1~h6), 主要在搜索中体现重要性, 对于整个文档的概括性. 这个标题在其他上下文中也会被使用，例如在用户的历史、书签，或搜索结果中</p></li><li><p>base</p><p>给网页上的URL提供相对地址的基础, 相当于<strong>根目录前缀</strong>, 只能有一个base. 它会改变全局的链接, 并不提倡使用.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.example.com/news/index.html&quot;</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Visit the <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;archives.html&quot;</span>&gt;</span>archives<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面例子中的链接地址是 “<code>https://www.example.com/news/archives.html</code>“。</p></li><li><p>style</p><p>css样式表</p></li></ul><h4 id="最重要的meta"><a href="#最重要的meta" class="headerlink" title="最重要的meta"></a>最重要的meta</h4><p>meta是作为title, base, link等的补充, 而实际上meta类型是开发者常见的优化方向. 本质是key-value.</p><p>使用meta要注意:</p><ul><li>必须指定任意一个: <code>name</code>，<code>http-equiv</code>，<code>charset</code>， 和 <code>itemprop</code>( 除了itemprop其他的都要同时指定content)</li><li>每个文档必须存在不少于一个有 <code>charset</code> 属性的 <code>meta</code> 元素。</li></ul><p>可以自定义meta, 约定好name和value即可, 也可以使用预定义的规范meta.</p><p>主要预定义的类型有这几项:</p><ol><li><p>html5简化了meta的charset写法, 新增charset属性用于设置网页的编码. 即:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>进行utf-8(ASCII是utf-8的子集)编码是因为一般http请求过程, 服务器会设定编码格式, 但应对一些非http协议无请求头, 如file, 就可以避免乱码情况.</p></li><li><p>具有http-equiv属性的meta, 执行命令, 一般是添加http头, 即content-type, 可以同时设定编码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;content-type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>name为viewport的meta, 设置网页缩放, 响应式设计中最常用.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述是移动端响应式设计中最典型的使用, 其中content设置<code>key</code>=<code>value</code>, 中间使用逗号分隔.</p><p>属性解释:</p><ul><li>width：页面宽度，可以取数值，一般设置成 device-width，即设备宽度。 </li><li>height：页面高度，可以取数值，一般设置成 device-height，即设备高度。 </li><li>initial-scale：初始缩放比例. (一般为1)</li><li>minimum-scale：最小缩放比例。 (一般为1)</li><li>maximum-scale：最大缩放比例。 (一般为1)</li><li>user-scalable：是否允许用户缩放。(对于移动端已有响应式设计就设置为no)</li></ul></li><li><p>description\application-name, 前者描述网页, 后者提供网页应用的名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">application-name</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;mugu&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;this is a description&gt;</span></span><br></code></pre></td></tr></table></figure><p>对于description, 在网页搜索中比较重要, 对于信息的提取也比较高效</p><p>而application-name是为网页应用设置的, 可以用作标签收藏时的使用, 利于浏览器算法生成.</p></li><li><p><strong>keyword弃用</strong>, 很多搜索引擎不会考虑这些关键字，因为该特性是不可靠的甚至会导致垃圾结果，对用户并没有帮助。特别是面对一些作弊, 恶意填充的keyword, 浏览器搜索引擎基本不作为考量.</p></li><li><p>referrer, generator, theme-color……</p></li></ol><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接包括两种, <strong>超链接</strong>和<strong>外部资源</strong>链接, 其中核心就是互联网的URL和URI系统.</p><p><strong>URI 指的是一个资源，URL 指的是用地址定位一个资源，URN 指的是用名称定位一个资源。 即URL 和 URN 是 URI 的子集。</strong> 详细可见引用[4]</p><p>在网页中链接最重要的两个属性是<strong>rel</strong>和<strong>href</strong>, 前者是Relationship, 指链接目标文档和本文档的关系; 后者表示Hypertext Reference, 指超链接的目标地址. 把握这两者的对应关系可以更好的理解和使用响应的标签.</p><p>网页中的链接主要有以下:</p><h4 id="link"><a href="#link" class="headerlink" title="link"></a>link</h4><ol><li>rel属性, 不同的功能</li></ol><p>link最主要的使用时链接外部资源. 即<strong>外部资源类链接</strong>. 常见在head标签中, 进行<strong>stylesheet</strong>关系的css文件引用.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;theme.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>大多情况向link不会显示在网页中, 作为元数据的一类, 其设计的目的是为了浏览器和搜索引擎识别. 比如icon资源, 会被浏览器识别:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/atom+xml&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/blog/news/atom&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 移动端提供不同分辨率, 此处的apple开头rel为ios特有 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;114x114&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon114.png&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;72x72&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon72.png&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此外指定不同的rel可以有不同的功能, 如<strong>preload</strong>预加载一些资源文件( 只是缓存, 未执行, 同常加上type属性声明MIME类型 ); 使用<strong>prerender</strong>可以预渲染页面, 这在确定用户会接下的页面中设置, 来访问可以极大提升用户体验.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;sintel-short.mp4&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;video&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prerender&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>as</code>属性指定加载资源的类型，它的值一般有下面几种。</p><ul><li>script</li><li>style</li><li>image</li><li>media</li><li>document</li></ul><p>还有一些其他信息类的元数据用途, 即提供给搜索引擎\浏览器等, 此类一般为<strong>超链接类链接</strong>, 当rel指明为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 作者信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;humans.txt&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 版权信息 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;license&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;copyright.html&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 另一个语言的版本, 通常由搜索引擎判别; 也可由插件判断RSS订阅链接 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://es.example.com/&quot;</span> <span class="hljs-attr">hreflang</span>=<span class="hljs-string">&quot;es&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/atom+xml&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/blog/news/atom&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 联系方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;me&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://google.com/profiles/someone&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/html&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;me&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:name@example.com&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;me&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;sms:+15035550125&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 历史资料 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;archives&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/archives/&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 目录 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 导航, 主要在分页浏览的业务场景中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;first&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;last&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/?page=42&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prev&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/?page=1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;next&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/article/?page=3&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 部分来自wangdoc.com --&gt;</span><br></code></pre></td></tr></table></figure><p>当然有些已经被meta元数据替代.</p><ol start="2"><li><p>media属性, 外部资源生效的媒介条件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;print.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;print&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mobile.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen and (max-width: 600px)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>和css的媒体查询类似, 在不同条件下, 加载不同的文件资源.</p></li><li><p>其他属性</p><p><code>&lt;link&gt;</code>标签的其他属性如下。</p><ul><li><code>crossorigin</code>：加载外部资源的跨域设置。</li><li><code>href</code>：外部资源的网址。</li><li><code>referrerpolicy</code>：加载时<code>Referer</code>头信息字段的处理方法。</li><li><code>as</code>：<code>rel=&quot;preload&quot;</code>或<code>rel=&quot;prefetch&quot;</code>时，设置外部资源的类型。</li><li><code>type</code>：外部资源的 MIME 类型，目前仅用于<code>rel=&quot;preload&quot;</code>或<code>rel=&quot;prefetch&quot;</code>的情况。</li><li><code>title</code>：加载样式表时，用来标识样式表的名称。</li><li><code>sizes</code>：用来声明图标文件的尺寸，比如加载苹果手机的图标文件。</li></ul></li></ol><h4 id="a"><a href="#a" class="headerlink" title="a"></a>a</h4><p>a标签指anchor, 即锚点, 在网络中定下信标就是a标签的功能. a标签于link同样具有rel和href, 也可充当元数据, 且rel的:</p><p>alternate \ author \ help \ license \ next \ prev \ search</p><p>与link的语义相同, 不同的是, <strong>a会显示在页面上,</strong> 更多是阅读用途. </p><p>除了常用的链接, 还有几个比较重要的用法:</p><ul><li><p><strong>download</strong>属性, 表示当前链接用于下载, 如下例, 文件名为bar.exe, 也可省略.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;foo.exe&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;bar.exe&quot;</span>&gt;</span>点击下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，如果链接点击后，服务器的 HTTP 回应的头信息设置了<code>Content-Disposition</code>字段，并且该字段的值与<code>download</code>属性不一致，那么该字段优先，下载时将显示其设置的文件名。</p></li><li><p><strong>mailto</strong>协议, 打开本机默认的邮件程序发送邮件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:contact@example.com&quot;</span>&gt;</span>联系我们<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 详细用法可以指定邮件的主题\日期等, 注意需要转义, %20为空格 --&gt;</span><br>&lt;a<br>  href=&quot;mailto:foo@bar.com?cc=test@test.com&amp;subject=The%20subject&amp;body=The%20body&quot;<br>&gt;发送邮件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 分享网页的用法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:&quot;</span>&gt;</span>告诉朋友<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4><p>作为交互的灵魂, script标签加载脚本代码, 执行JavaScript程序. </p><p>最重要的就是type属性, 一般默认是”text/javascript”. 还有下面一些其他属性，大部分跟 JavaScript 语言有关.</p><ul><li>async：该属性指定 JavaScript 代码为异步执行，不是造成阻塞效果，</li><li>JavaScript 代码默认是同步执行。</li><li>defer：该属性指定 JavaScript 代码不是立即执行，而是页面解析完成后执行。</li><li>crossorigin：如果采用这个属性，就会采用跨域的方式加载外部脚本，即 HTTP 请求的头信息会加上origin字段。</li><li>integrity：给出外部脚本的哈希值，防止脚本被篡改。只有哈希值相符的外部脚本，才会执行。</li><li>nonce：一个密码随机数，由服务器在 HTTP 头信息里面给出，每次加载脚本都不一样。它相当于给出了内嵌脚本的白名单，只有在白名单内的脚本才能执行。</li><li>referrerpolicy：HTTP 请求的Referer字段的处理方法。</li></ul><p><code>&lt;noscript&gt;</code>标签用于浏览器不支持或关闭 JavaScript 时，所要显示的内容. noscript不是一个功能性标签, 我个人感觉更像是一种人性化的设计, 虽然有些争议, 但是在某些层面noscript照顾到一部分人的利益. 可以查阅这篇博客<a href="https://www.smashingmagazine.com/2018/05/using-the-web-with-javascript-turned-off/">🔗I Used The……</a>[5]</p><p>要注意的是href和src虽然都是提供了URL, 但是两种用本质区别, 即前者为替换型标签, 引入资源后替换自身, 如script. 但href则是链接到外部的标签.</p><p>那为什么style标签不能像script一样使用src呢? 而是要link链接? 下篇博客详细讨论相关内容和媒体标签的引用.</p><p>以上为链接相关的内容.</p><p><em>引用</em></p><ol><li>HTML Standard. (2021). Retrieved 18 February 2021, from <a href="https://whatwg-cn.github.io/html">https://whatwg-cn.github.io/html</a></li><li>文档级元数据元素 - HTML（超文本标记语言） | MDN. (2020). Retrieved 18 February 2021, from <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta</a></li><li>链接标签. (2021). Retrieved 19 February 2021, from <a href="https://wangdoc.com/html/link.html">https://wangdoc.com/html/link.html</a></li><li>URI、URL 和 URN 的区别. (2019). Retrieved 19 February 2021, from <a href="https://juejin.cn/post/6844904003348725767">https://juejin.cn/post/6844904003348725767</a></li><li>I Used The Web For A Day With JavaScript Turned Off — Smashing Magazine. (2018). Retrieved 19 February 2021, from <a href="https://www.smashingmagazine.com/2018/05/using-the-web-with-javascript-turned-off/">https://www.smashingmagazine.com/2018/05/using-the-web-with-javascript-turned-off/</a></li></ol><h2 id="04-HTML嵌入型元素-媒体标签"><a href="#04-HTML嵌入型元素-媒体标签" class="headerlink" title="04 HTML嵌入型元素(媒体标签)"></a>04 HTML嵌入型元素(媒体标签)</h2><p>上篇博客提到了链接, 主要讲述的是link, a, script等链接型元素. 与之相对的是嵌入在网页中的内容, 嵌入内容对应的嵌入型元素主要是一些多媒体标签. 它们主要是img, video, audio, iframe等. 本文一一复盘.</p><h4 id="为什么style标签没有src"><a href="#为什么style标签没有src" class="headerlink" title="为什么style标签没有src?"></a>为什么style标签没有src?</h4><p>开始复盘前, 先理解一下嵌入型和链接型的区别.</p><p><img src="C:\Users\Mr.yang\AppData\Roaming\Typora\typora-user-images\image-20210220221057875.png" alt="image-20210220221057875"></p><p>相关tweet中, 老哥的这段话的大意是:  网页中某个具有src属性的标签, 是让浏览器去<strong>引用并嵌入</strong>到这个标签的位置.</p><p>而从功能角度思考, stylesheets作用在整个文档, 和文档是有对应的, 明确的<strong>1对1的映射关系</strong>. 而非其他嵌入在其中的包含关系. 所以, 有以下可能的原因和结论:</p><ul><li><p>style标签与页面不是嵌入关系, 故没有src, 至于为什么没有href, 而是用link来描述样式表, 可能是</p><ul><li>有一定的<strong>历史遗留和设计原因</strong>, 起初的css发展和html不同步, 可能有设计层面的原因</li><li>link更能<strong>抽象和描述</strong>样式表这一外部文件和文档的关系.</li></ul></li><li><p><strong>包含src的元素是嵌入型, 包含href的是链接型元素</strong></p></li></ul><p>其实, script标签和页面也可以归纳为一种对应关系, 应该也可以使用link去引入. 但是个人认为, 从浏览器工作层面考量则应更注重内联和引用的层面. 所以部分知识有争议和待求解很正常, 需要用辩证, 客观的想法去学习, 没有本来就那样的道理, 学会从语言设计层面去思考问题.</p><h4 id="嵌入型多媒体标签"><a href="#嵌入型多媒体标签" class="headerlink" title="嵌入型多媒体标签"></a>嵌入型多媒体标签</h4><ol><li><p><strong>img</strong></p><p>img是大家非常熟悉的标签了, 基础略过, 一些重要的属性和优化如下:</p><ul><li><p><strong>alt</strong></p><p>alt这个属性一般用户没有什么感受, 最多在图片加载失败时候, 看到一张破碎的图标和”img”的字样.</p><p>事实上, alt是对于视障人士最大的关怀. alt可以放置描述性的文字用以机器阅读, 是特别重要但又容易被忽略的一点.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;一只小狗在奔跑&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>正确的alt应该是如上面所示, 描述图片, 而非”图片”, “示例图片”, 这也是容易被忽略的. 这是做到网址可达性的重要一点.</p></li><li><p><strong>loading</strong></p><p>设置懒加载, 对于浏览较多, 较长的图文会非常有用, 只有当用户交互到的时候才进行加载, 即节省带宽流量, 有提高网页加载速度. </p><p>loading属性可以取以下三个值。</p><blockquote><ul><li><code>auto</code>：浏览器默认行为，等同于不使用<code>loading</code>属性。</li><li><code>lazy</code>：启用懒加载。</li><li><code>eager</code>：立即加载资源，无论它在页面上的哪个位置。</li></ul></blockquote><p>由于图片的懒加载, 会导致页面重排, 影响性能. 所以一般设置好宽高.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.png&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;…&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>data uris</strong></p><p>这类data:uri的图片引入也是常用的技巧, <strong>用来减少文件的引入, 从而减少http请求, 提升网页性能</strong>. 替换调url为data uris. 格式如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">data:[<span class="hljs-tag">&lt;<span class="hljs-name">mime</span> <span class="hljs-attr">type</span>&gt;</span>][;charset=<span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>][;base64],<span class="hljs-tag">&lt;<span class="hljs-name">encoded</span> <span class="hljs-attr">data</span>&gt;</span><br></code></pre></td></tr></table></figure><p>常见的就是base64的图片编码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;star&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;16&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;16&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以通过一些在线的网址提取图片的base64编码, 比如这个<a href="https://websemantics.uk/tools/image-to-data-uri-converter/">online base64 converter</a></p><p>转换后base64的图片相比原来的可能会增加30%的大小, 因为通过较长的字符串来替代, 所以会<strong>降低可读性</strong>, 同时如果写在css中, 会<strong>增加css的体积</strong>, 但是可以通过压缩解决这个问题. 但是用base64有更明确的场景条件:</p><ul><li>被编码的图片较小, 且复用性高, 不经常刷新. 如用50X50字节的图片去平铺背景图</li><li>不用额外的请求</li><li>无法使用cssSprite的独立性较高的图片.</li></ul><p>特别是<strong>数量大, 独立性强, 体积小</strong>的图片. 这点和cssSprite比较像, 但两者还是有区别的. 可以参考这位博主的分析, <a href="https://www.imooc.com/article/27804"><strong>图片Base64编码的利与弊分析</strong></a>.</p><p>不要盲目使用base64, 不是说可以减少图片请求就可以提高网页速度, 要<strong>因地制宜地使用</strong>, 否则: </p><p><img src="https://i.loli.net/2021/02/21/61IEzpmohqOWaSV.png" alt="image-20210221111951829"></p><p>(应该是主要用base64)加载图片的网址比单纯使用二进制链接(即src等)的网址慢了6倍!</p></li><li><p><strong>srcset, sizes</strong></p><p>srcset可以为图片设置不同url地址, 主要用于移动端的<strong>响应式设计</strong>, 采用不同的图片尺寸来实现.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;foo-160.jpg 160w,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-320.jpg 320w,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-640.jpg 640w,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-1280.jpg 1280w&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;(max-width: 440px) 100vw,</span></span><br><span class="hljs-tag"><span class="hljs-string">            (max-width: 900px) 33vw,</span></span><br><span class="hljs-tag"><span class="hljs-string">            254px&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo-1280.jpg&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;foo-320w.jpg,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-480w.jpg 1.5x,</span></span><br><span class="hljs-tag"><span class="hljs-string">             foo-640w.jpg 2x&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo-640w.jpg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>srcset</code>属性给出了三个图像 URL，适应三种不同的<strong>像素密度</strong>.</p><p>图像 URL 后面的像素密度描述符，格式是像素密度倍数 + 字母<code>x</code>。<code>1x</code>表示单倍像素密度，可以省略。浏览器根据当前设备的像素密度，选择需要加载的图像。</p><p>如果<code>srcset</code>属性都不满足条件，那么就加载<code>src</code>属性指定的默认图像。</p><p>而 <code>sizes </code>属性, 则是用于选择不同的<strong>屏幕宽度</strong>. 当不同尺寸的条件发生, 则显示不同宽度的图片.</p><p>事实上, 更好的做法是使用picture标签. 同时兼具像素和屏幕选择的两种功能.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/svg+xml&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;logo.xml&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/webp&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;logo.webp&quot;</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;logo.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;ACME Corp&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>video</strong></p><p>去年正式歇菜Flash一度是web视频的独有者, h5播放器如今发展得越来越好. 一般来说, 会指定多个视频源:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span> &gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br> You browser does not support video.<br>&lt;/video<br></code></pre></td></tr></table></figure><p>上面三种是video支持的主流视频格式. 分别是VP8 \ Theroa \ H.264对于的协议专利.至于为什么没有统一的h5的是视频格式, 可以追溯到各个厂家的竞争, 参考阮一峰翻译的<a href="http://www.ruanyifeng.com/blog/2010/05/html5_codec_fight.html">HTML5的视频格式之争</a>.</p><p>不支持h5播放器就会显示标签中的内容. 同时可以参考各个属性进行设置, 参见MDN.</p><p>audio属性基本和video一致.</p></li><li><p><strong>iframe</strong></p><p>iframe在网页开辟新的文档空间. 一般通过iframe嵌入其他网页. iframe并不被推荐使用, 一方面是网络安全问题, 容易利用iframe的漏洞进行攻击; 另一方面, 移动端显示问题, 还有诸多限制……此外还涉及到跨域问题. 一般网站都会通过http头禁止自身被设置为iframe.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-FRAME-OPTIONS&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;DENY&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新标准增加了sandbox, 更加方便设置, 可以解决跨域问题, 权限管理等:</p><p><code>sandbox</code>属性可以设置具体的值，表示逐项打开限制。未设置某一项，就表示不具有该权限。具体可以查看MDN.</p><p>注意，不要同时设置<code>allow-scripts</code>和<code>allow-same-origin</code>属性，这将使得嵌入的网页可以改变或删除<code>sandbox</code>属性。</p></li></ol><p><em>参考引用</em></p><ol><li>Data URIs | CSS-Tricks. (2010). Retrieved 21 February 2021, from <a href="https://css-tricks.com/data-uris/">https://css-tricks.com/data-uris/</a></li><li>Foskett, M. (2020). Image to base64 data-URI converter. Retrieved 21 February 2021, from <a href="https://websemantics.uk/tools/image-to-data-uri-converter/">https://websemantics.uk/tools/image-to-data-uri-converter/</a></li><li>&lt;img&gt;：图像嵌入元素 - HTML（超文本标记语言） | MDN. (2020). Retrieved 21 February 2021, from <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img</a></li><li>图像标签. (2021). Retrieved 21 February 2021, from <a href="https://wangdoc.com/html/image.html">https://wangdoc.com/html/image.html</a></li></ol><h2 id="05-HTML表格表单和ARIA"><a href="#05-HTML表格表单和ARIA" class="headerlink" title="05 HTML表格表单和ARIA"></a>05 HTML表格表单和ARIA</h2><p>本篇博客大致回忆下表单表格的特点, 用法和注意事项. 还有重点复盘下ARIA系统的概念.</p><h3 id="为什么不建议用要表格"><a href="#为什么不建议用要表格" class="headerlink" title="为什么不建议用要表格?"></a>为什么不建议用要表格?</h3><p>感兴趣可以先上StackOverflow查看这个当时table正火的帖子:</p><p><a href="https://stackoverflow.com/questions/83073/why-not-use-tables-for-layout-in-html">Why not use tables for layout in HTML? [closed]</a></p><p>你要是看了高赞的分析, 估计对table的弊端有大致的了解了. 个人认为web的发展并没有改变多少table的本质.</p><p><em>html的 <strong><code>table</code></strong> 元素表示表格数据 — 即通过二维数据表表示的信息</em>  –MDN</p><p>table本意就是拿来渲染表格数据的, 按道理来说没什么问题, 各司其职. 但是主要涉及三个问题:</p><ul><li><strong>SEO和语义化问题</strong>, 事实上, <code>table</code> 并没有很好地语义化, 想象下, 大量的<code>table</code> 数据内容混杂, 用户搜索自然也不会集中到数据本身, 搜索权重自然就小. 而且本身的阅读性不是很好, 设计太过朴素难以突出重点, 特别是现在花里胡哨的网站中.</li><li><strong>可访问性(Accessibility)差</strong>, 特别在屏幕阅读和视障人群地使用中, 遇上大量数据很难阅读和被正确地识别. 基本措施是&lt;caption&gt;\ &lt;summary&gt;进行表格数据描述, 或是设置scope属性等.</li><li><strong>浏览器渲染性能问题</strong>, <code>table</code> 的性能一直被人们诟病. 特别是在渲染方面, 需要表格加载完毕才开始渲染布局, 会有明显的割裂感和延迟. 主要和浏览器的渲染算法有关, 特别应对大量数据时, 缓存也是个问题.</li></ul><p>HTML设计思想是<strong>内容样式分离的</strong>, 使用CSS样式表来管理样式. 而这个<code>table</code> 却是兼具两者, 所以在浏览器行为方式不同也可以理解, 而且CSS更容易缓存. 目前<code>table</code> 的大量全局属性被抛弃<sup><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table#%E5%B1%9E%E6%80%A7">MDN🔗</a> </sup>, 建议使用CSS管理样式, 也说明了W3C正在分解<code>table</code> . </p><p>不论怎样, 目前都是不建议使用<code>table</code> 进行布局的, 要我说直观点就是排版麻烦不好看, 还有各种小毛病XD.</p><p>基本用法可以参考阮一峰 <a href="https://wangdoc.com/html/table.html">表格标签🔗</a>.</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>表单可以说是学习web中第一个碰到交互最多的组件. </p><p><code>name</code> 和<code>id</code> 的疑惑, 刚开始学习HTML的时候, 觉得<code>name</code> 和<code>id</code> 在大多数情况下的用途是一样的, 为什么不合并呢? 而在学习了<code>form</code> 之后, 才了解这样设计的部分原因. </p><ul><li><p><code>label</code>标签对应一个<code>input</code>, 关联的是<code>input</code>的<code>id</code>属性, 而非<code>name</code>属性, 此外除了常用的并列排布, 还可以包裹, 这是可以省略<code>for</code>和<code>id</code>属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>用户名：<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>name</code> 属性是关系到服务器的字段信息获取, 需要通过<code>name</code>来获取属性.<br>此外表单的单选操作中会设置同个<code>name</code> .</p></li></ul><p>基本用法参考阮一峰 <a href="https://wangdoc.com/html/form.html">表单标签🔗</a>. 基础上没什么可以总结提炼的, 反观国内的框架也主要的是围绕<strong>表单优化</strong>展开. 而最重要的, 除了网络优化, 就是用户体验.</p><p>在用户体验方面, 可看看这篇博客 <a href="https://cxl.com/blog/form-design-best-practices/">Form Design: 13 Empirically Backed Best Practices</a>. 总结了一下重要的表表单开发和优化经验:</p><ul><li><p><strong>少即是多</strong>, 减少输入框👇( 对比两图, 后面多清爽 )<br><img src="https://i.loli.net/2021/02/25/wTonAbDg2NceBZ9.jpg" alt="img"><br><img src="https://i.loli.net/2021/02/25/nQp1E8MZFTYKtUG.png" alt="image-20210225234802974"></p></li><li><p><strong>单流</strong>向结构更易读, 更高效. 特别是移动端设备占主要成分的情况下.<br><img src="https://i.loli.net/2021/02/25/TsZtiYr5Nzmc43S.jpg" alt="image comparing a single-column vs. multi-column form design."></p></li><li><p>做好跟随的<strong>内联校验</strong>. 提高表单填写效率, 而非提交后才提示失败信息, 会严重挫败用户体验.</p></li><li><p>设置<strong>自动聚焦</strong>, 特别是移动端</p></li><li><p>增加<strong>显示密码</strong>, 有调查表明, 掩饰密码实际上没有对安全有多少影响, 反倒不变用户校验. 所以个人认为增加明文显示以供校验更加友好. can’k参考github的登陆界面:<br><img src="https://i.loli.net/2021/02/25/MEYkt3f1KrsvgS5.png" alt="image-20210225235656213"></p></li></ul><p>此外, 还有两点值得注意:</p><ul><li><p><strong>移除form表单默认跳转事件</strong>, <code>form</code> 和服务器打交道, 较多使用ajax技术进行提交, 为了防止默认的提交行为导致后续代码无法执行( 如弹窗, 回调函数等 ), 可以使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> submit = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">//移除默认行为</span><br>    $(<span class="hljs-string">&#x27;form&#x27;</span>).on(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>        e.preventDefault();<br>        <span class="hljs-comment">//ajax请求代码:</span><br>        <span class="hljs-comment">//....</span><br>        &#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>防止重复提交</strong>. 策略可以是页面跳转, 前端校验式添加锁机制( 用默个字段控制状态 ), 后端服务器字段校验等.</p></li></ul><h3 id="ARIA"><a href="#ARIA" class="headerlink" title="ARIA"></a>ARIA</h3><p>ARIA全称: Accessible Rich Internet Applications 可访问富互联网应用, 即大家口中的无障碍, 是一个<strong>可访问性的标准</strong>.  有时候你会看到WAI-ARIA, 其中WAI = Web Accessibility Initiative, 即无障碍网页倡议. 两者指代的都是同意思.</p><p>可以把它当作HTML5标签的<strong>属性扩展</strong>. 主要可以<strong>支持屏幕阅读等辅助技术, 提供语义化信息</strong>. </p><p>现代浏览器基本支持ARIA, 即使不支持也不会造成问题, <strong>ARIA并不会改变标签的功能表现</strong>. </p><p>ARIA是在HTML4之后引入的, 更像是一个过渡时期的机制. 因为<strong>许多ARIA规范在HTML5中已经实现语义化</strong>标签, 但是仍然发挥着重要的补充功能.</p><h4 id="ARIA不只是视障关怀"><a href="#ARIA不只是视障关怀" class="headerlink" title="ARIA不只是视障关怀"></a>ARIA不只是视障关怀</h4><p>初识AIRA可能会误解为专为视障用户使用的关怀手段. 实际上, ARIA属于可访问性的范畴, 从语义化 \ 辅助阅读等角度都是AIRA的重点, HTML5实现相关ARIA属性为标签也可见一斑. 所以ARIA不只是特定用户的辅助技术, <strong>更是衡量一个优秀网站的标准</strong>.</p><p>而且, 对于javascript程序为基础的web应用, 许多功能 \ 组件无法使用HTML标签去语义化表达, 这时候ARIA就发回了很大的扩展作用. </p><p>例如, 一个弹出式UI组件, 面包屑导航等在框架中常见的组件; 再从框架中的组件中也可以看出目前HTML没有的语义化表达.</p><h4 id="实现原理和应用"><a href="#实现原理和应用" class="headerlink" title="实现原理和应用"></a>实现原理和应用</h4><p>ARIA 通过更改和补充标准 DOM 无障碍树来发挥作用。而且<strong>ARIA 不会补充元素的任何固有行为</strong>；</p><p><img src="https://i.loli.net/2021/02/26/4xEBWCaZ1sDzPFQ.png" alt="image-20210226173451402"><img src="https://i.loli.net/2021/02/26/ojC4g7eX6LM5ir3.png" alt="image-20210226173512018"></p><p>通过DOM的修改\创建不存在HTML标签中的语义化元素, 大概可以实现以下功能:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 扩展语义, eg:创建了一的只读标签 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;screen reader only label&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 定义父子组件的关系, eg:控制特定区域的自定义滚动条 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;scrollbar&quot;</span> <span class="hljs-attr">aria-controls</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><br>. . .<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 辅助技术API, eg:页面发生变化时立即通知辅助技术 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">aria-live</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>GOOG: $400<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>......<br></code></pre></td></tr></table></figure><h4 id="role体系"><a href="#role体系" class="headerlink" title="role体系"></a>role体系</h4><p>ARIA 系统的其中一个核心层面是其<code>role</code>集。在无障碍术语中，角色是指特定 UI 模式的简略指示器.</p><p><strong>换句话说, 可以将下面属性值理解成新的未纳入规范的语义化标签.</strong></p><p><img src="https://i.loli.net/2021/02/26/5dSkZFcGXRNJbxB.png" alt="image-20210226112447841"></p><p>可见, 有些<code>role</code> 在h5中成为了新标签( 图中红框圈出了部分 ), 把ARIA看出过渡也是一种观点. </p><p>看一看<code>role</code> 属性如何使用:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clock&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;timer&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;tomato-timer&quot;</span> <span class="hljs-attr">aria-roledescription</span>=<span class="hljs-string">&quot;这是个番茄钟, 计时25分钟&quot;</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span>25mins<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;startTimer(&#x27;clock&#x27;)&quot;</span>&gt;</span>开始计时<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义了<code>timer</code>这个计时器, 相关的<code>aria- </code> 属性让辅助手段判断其UI变化. 一般这种变化是通过js操作的, 而且<code>aria-</code> 更多在js应用中使用.</p><p>此处<code>timer</code> 对应的<code>aria-label</code> 描述其名称, <code>aria-roledescription</code> 添加更加具体的说明以供屏幕阅读器朗读等.</p><p>在WAI-ARIA中可以找到各个<code>role</code> 对应的属性  <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles">aria role🔗</a></p><p>role的使用很简单, 要更好地认识可以将其粗略分为widget部件和section组成:</p><ul><li><strong>widget</strong><ul><li>功能型:  button, alert, link, timer, progressbar, scrollbar, separator</li><li>表单型:  checkbox, radio, option, slider, slider, textbox, spinbutton</li><li>复合型:  tab, tree,  menu, list, grid…..</li></ul></li><li><strong>section</strong><ul><li>h5中实现了很大一部分, 请直接使用. 如article, </li><li>Landmark, 直接翻译地标, ARIA标准中的<strong>八结构页面</strong>组成:<ul><li>Banner  ( 开发习惯常用banner头图 )</li><li>Navigation  ( eg: nav标签, 导航栏 )</li><li>Form  ( 表单 )</li><li>Main   ( 主体 )</li><li>Application  ( web应用本身 )</li><li>Search  ( 搜索功能 )</li><li>complementary  ( eg: aside标签补充说明, 辅助内容 )</li><li>contentinfo  ( 内容注释, meta内容, 版权信息© )</li></ul></li></ul></li></ul><h4 id="AIRA的启发"><a href="#AIRA的启发" class="headerlink" title="AIRA的启发"></a>AIRA的启发</h4><p>可见, ARIA是更加抽象的标签, 对于理解网页结构, 文字排版等有重大的启发意义. 特别在进行组件设计时, 可以参考ARIA的设计思想, <strong>由概念到属性, 进一步抽象, 封装成可用组件.</strong> 很多UI框架的组件就可以看成高一层的封装, 如各种tabbar\scroll-view\list等等.</p><p><em>引用</em></p><ol><li><p>&lt;table&gt;- HTML（超文本标记语言） | MDN. (2020). Retrieved 26 February 2021, from <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table</a></p></li><li><p>ARIA - 无障碍 | MDN. (2020). Retrieved 26 February 2021, from <a href="https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/ARIA">https://developer.mozilla.org/zh-CN/docs/Web/Accessibility/ARIA</a></p></li><li><p>Introduction to ARIA  | Web Fundamentals  | Google Developers. (2021). Retrieved 26 February 2021, from <a href="https://developers.google.com/web/fundamentals/accessibility/semantics-aria#:~:text=%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3,%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%A3%B0%E6%98%8E%E3%80%82">https://developers.google.com/web/fundamentals/accessibility/semantics-aria#:~:text=%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3,%E8%83%BD%E6%AD%A3%E7%A1%AE%E5%A3%B0%E6%98%8E%E3%80%82</a></p></li><li><p>Birkett, A. (2019). Form Design: 13 Empirically Backed Best Practices | CXL. Retrieved 26 February 2021, from <a href="https://cxl.com/blog/form-design-best-practices/">https://cxl.com/blog/form-design-best-practices/</a></p></li><li><h4 id="ARIA-Landmark-Roles-2021-Retrieved-26-February-2021-from-https-www-washington-edu-accessibility-web-landmarks"><a href="#ARIA-Landmark-Roles-2021-Retrieved-26-February-2021-from-https-www-washington-edu-accessibility-web-landmarks" class="headerlink" title="ARIA Landmark Roles. (2021). Retrieved 26 February 2021, from https://www.washington.edu/accessibility/web/landmarks/"></a>ARIA Landmark Roles. (2021). Retrieved 26 February 2021, from <a href="https://www.washington.edu/accessibility/web/landmarks/">https://www.washington.edu/accessibility/web/landmarks/</a></h4></li><li><p>表格标签. (2021). Retrieved 26 February 2021, from <a href="https://wangdoc.com/html/table.html">https://wangdoc.com/html/table.html</a></p></li><li><p>表单标签. (2021). Retrieved 26 February 2021, from <a href="https://wangdoc.com/html/form.html">https://wangdoc.com/html/form.html</a></p></li></ol><p><em>转发备注出处, thanks~</em></p>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>木星疯人院</title>
    <link href="/2020/02/20/%E6%9C%A8%E6%98%9F%E7%96%AF%E4%BA%BA%E9%99%A2/"/>
    <url>/2020/02/20/%E6%9C%A8%E6%98%9F%E7%96%AF%E4%BA%BA%E9%99%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="木星疯人院"><a href="#木星疯人院" class="headerlink" title="木星疯人院"></a>木星疯人院</h2><p><em>这是一个荒诞的梦，似乎有点玄幻，但我应该记录下来。因为至今我还未曾做过一个如此记忆犹新的梦，某种至在莫种程度上，出乎真实。</em></p><p><img src="https://mixkit.imgix.net/art/419/419-square.png?w=200&h=441&q=80&auto=format,compress&q=80&dpr=1"></p><p>我又醒了，在不知名的灰白色房间里，床榻也是灰白的，朦胧的阳光透过灰白到发黄的窗帘晕染了我的视线。</p><p>今天又是一份试卷，我不知道为什么要做试卷，貌似和早餐一样，是我起床第一件要做的事情。也不多想，就是做完它，但也每次都记不起来试卷的内容是什么。</p><p>之后便出现一位少女，在我房间，也不知道她在做什么，我甚至没有看过她，但是，冥冥中就存在一样，我就是知道那是一位女性，而且不可触及，但是可以感知。</p><p>我继续呆在原地，好像有发生点什么。</p><p>不知怎么的，我站在一幢灰白相间的礼堂前，有着几十阶的阶梯，我在阶梯上，看着周围突兀的绿水青山，而且只有青绿的边界，没有山峦的细节，仿佛乐高玩具捏造的一般。堂前停放了一辆小型的厢式货车，有一位很健谈的司机，和我们很聊得来，哦，我们是指我和另外两个朋友，一个记得清是谁，一个就不得而知了。</p><p>我们聊了一会，我一位朋友爬上货车顶躺下休息。我们在等待，等待货车司机出货，大概聊天的内容也是关于这些吧。</p><p>好像就这样过了好几天，这样的“天”周期很短，至少不是24小时，也不会觉得无聊，甚至很期待货车司机什么时候去出货，至于出的是什么货，没有人关心，像是期待探险队临行前的兴奋。</p><p>后来没等到司机出货，等来了一群新人，素不相识，玩笑打闹，像是很有趣。</p><p>我自然是加入到他们一列，并走进了礼堂，说是礼堂，其实就是一间间空旷的教室，一直有着5点20下课的黄昏景色，很是怀旧，而且单调。</p><p>我们自然是呆不住，东走走，西走走，不知怎么的，总会遇到死路。</p><p>最后一次走动，我们遇到了一处木栅栏挡住了去路，前面是两位穿着警察制服的人在向路人打听消息。无路可去，我们便悻悻而归。</p><p>我再一次在灰白的房间醒来，这次试卷有了内容，几道单选，几道填空，还有一道问答。</p><p>这次有人在和我交流，是一个比我稍大的师兄（意义上的师兄，不特指），梦里无法发声，发声也是禁音的口型，他似乎在用思想和我交流，像是三体人一样。他正和我激动的介绍着一种新科技，将有机体与机械结合，目前已经实现了机械植物应用，将会进一步展开研究。</p><p>我很好奇，似乎梦里的除了好奇没有其他情绪。</p><p>我便继续填写试卷，试卷的大概内容就是关于这项技术的观点建议。</p><p>我把我的感受写了下去，这是一项不聪明的发明，并且告诫他们，不可在动物上使用，否则由灾难性的后果。</p><p>这时候潜意识里，我隐约觉得，这位男性和那位少女一样，和我在这里生活了很久，一直都在。</p><p>最后梦逐渐模糊，只有闪现的几个画面，大家都在逃命，赶往火箭航班。我站在礼堂外，遇到一位大学老师，寒暄后她便匆匆离开。</p><p>我站在原地，像是在登出。</p><p>后记：来自我的一个梦，梦里的事物大多在我的生活中找得到联系。不同以往的梦醒来就忘了，这次会有这么强烈的画面感，甚至有点连续和故事性，梦中的有机体与机械的技术，应用到了机械植物，礼堂和只有青绿色轮廓的山似乎在昭示着什么。而不可思议的是，一天的周期短，要乘坐火箭离开，这似乎不是在地球上。登出的操作让我想起了三体的那个三体人的脱水的游戏。而那对在灰白房间少年少女，我的感觉是物化的某种精神状态。</p><p>以上全部是我的梦，我基本真实的描述了下来，但太过真实，太过戏剧，不必较真，读者自斟。</p>]]></content>
    
    
    <categories>
      
      <category>南城六月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>梦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>display布局</title>
    <link href="/2020/02/19/display%E5%B8%83%E5%B1%80/"/>
    <url>/2020/02/19/display%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一-关于display"><a href="#一-关于display" class="headerlink" title="一 关于display"></a>一 关于display</h2><p>所有元素在网页上的存在形式都是长方体,而影响网页的布局的主要因素一方面是<a href="https://www.bukun.top/2020/02/11/%E5%AD%A6%E4%B9%A0%E9%80%9F%E8%AE%B0-html-ccs/#%E5%9D%97%E9%AB%98%E5%BA%A6-amp-amp-%E5%86%85%E8%81%94%E9%AB%98%E5%BA%A6">文档流</a>,一方面则是css控制的元素的表现形式display,其中常用的有:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline;        <span class="hljs-comment">/* Default of all elements, unless UA stylesheet overrides */</span><br>  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-comment">/* Characteristics of block, but sits on a line */</span><br>  <span class="hljs-attribute">display</span>: block;         <span class="hljs-comment">/* UA stylesheet makes things like &lt;div&gt; and &lt;section&gt; block */</span><br>  <span class="hljs-attribute">display</span>: run-in;        <span class="hljs-comment">/* Not particularly well supported or common */</span><br>  <span class="hljs-attribute">display</span>: none;          <span class="hljs-comment">/* Hide */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有元素默认的样式都是<strong>inline</strong>内联,而浏览器的用户代理脚本(<a href="https://stackoverflow.com/questions/12582624/what-is-user-agent-stylesheet">UA stylesheet</a>)会改变大部分的元素为<strong>block</strong>块</p><h2 id="二-概略MDN"><a href="#二-概略MDN" class="headerlink" title="二 概略MDN"></a>二 概略<sup><a href="https://developer.mozilla.org/en/CSS/display"><strong>MDN</strong></a><sup/></h2><h3 id="inline-内联"><a href="#inline-内联" class="headerlink" title="inline 内联"></a>inline 内联</h3><ul><li><p>元素的默认值,eg:  span em b…..</p></li><li><p>不会破坏文本的流动,以基线为准和其他元素保持在同一行内<img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2011/09/inline-element.png?w=346&ssl=1" alt="this"></p></li><li><p>使用margin和padding会在水平方向扩张但不会再垂直方向扩张,但不接受width height的值<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2011/09/inlinepadding.png?w=519&ssl=1" alt="css-tricks"></p></li></ul><h3 id="inline-block-内联块"><a href="#inline-block-内联块" class="headerlink" title="inline-block 内联块"></a>inline-block 内联块</h3><ul><li>基本与内联一致,但是不同的是有以下两点<ul><li>接受width height</li><li>水平和垂直方向的边距都会扩张<br><img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2011/09/inline-block.png?w=526&ssl=1" alt="css-tricks"></li></ul></li></ul><h3 id="block-块"><a href="#block-块" class="headerlink" title="block 块"></a>block 块</h3><ul><li>div\section\ul\p\h#….等会被浏览器设置为block显示</li><li>块级元素不会<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements">内联</a>,但是会跨过内联元素而被分割<br><img src="https://i2.wp.com/css-tricks.com/wp-content/uploads/2011/09/block.png?w=520&ssl=1" alt="css-tricks"></li></ul><h3 id="run-in-嵌入"><a href="#run-in-嵌入" class="headerlink" title="run-in 嵌入"></a>run-in 嵌入</h3><ul><li>火狐不支持</li><li>嵌入元素(如报纸首行前面的大字)<br><img src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2011/09/Run-in.png?resize=294,97" alt="css"></li></ul><h3 id="flex-弹性"><a href="#flex-弹性" class="headerlink" title="flex 弹性"></a><strong>flex 弹性</strong></h3><ul><li><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>Flexbox Layout（弹性盒）（W3C 2017推荐模块）的目标是提供一种更有效的方式来布置，元素在一个容器中对齐和分配空间，即使大小未知或者是动态的（单词“ flex”的来由）。</p><p>flex布局的主要思想是<strong>使容器能够更改其项目的宽度/高度（和顺序）</strong>，以<strong>最好地填充</strong>可用空间（用于适应显示设备和屏幕尺寸）。Flex容器会将元素扩大以填充可用的可用空间，或收缩它们防止溢出。</p><p>与常规布局（<strong>基于垂直的块和基于水平的内联块</strong>）相比，<strong>flexbox布局与方向无关</strong>。尽管这些样式对于页面效果很好，但是它们缺乏灵活性来支持大型或复杂的应用程序（尤其是在方向更改，调整大小，拉伸，缩小等方面）。</p><p><em>Flexbox适合app和小规模布局，而<a href="#gird-%E7%BD%91%E6%A0%BC">Grid</a>布局则用于较大规模的布局</em></p></li><li><h4 id="图形知识"><a href="#图形知识" class="headerlink" title="图形知识"></a>图形知识</h4><p><img src="https://css-tricks.com/wp-content/uploads/2018/11/00-basic-terminology.svg" alt="basic"><br>main axis:  主轴<br>cross axis: 交叉[横]轴  </p></li><li><h4 id="基础与术语"><a href="#基础与术语" class="headerlink" title="基础与术语"></a>基础与术语</h4></li><li><h5 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h5><ol><li><p>display: flex //或者inline-flex,colum属性无效</p></li><li><p>flex-direction: row | row-reverse | column | column-reverse;</p><ul><li>row（默认值）：从左到右ltr；从右到左rtl</li><li>row-reverse：从右到左的ltr; 从左到右rtl</li><li>column：与row上至下相同</li><li>column-reverse：与row-reverse下至上相同</li><li><img src="https://css-tricks.com/wp-content/uploads/2018/10/flex-direction.svg" alt="img"></li></ul></li><li><p>flex-wrap: nowrap | wrap | wrap-reverse;<br> 以不同的缠绕方式排列,分别为<strong>一行||缠绕||反向缠绕</strong><br><img src="https://i.loli.net/2020/02/20/sPGW1ERuAlMeDfT.png" alt="批注 2020-02-20 114204.png"></p></li><li><p>flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;缩写</p></li><li><p>justify-content<br> 分配顺着父容器主轴的弹性元素之间及其周围的空间<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/justify-content.svg" alt="img"></p></li><li><p>align-items<br> justify在垂直方向的布局<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/align-items.svg" alt="csst"></p></li><li><p>align-content<br> 类似于将整体视为单个元素进行justify的排列<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/align-content.svg" alt="csst"></p></li></ol></li><li><h5 id="children元素的属性"><a href="#children元素的属性" class="headerlink" title="children元素的属性"></a>children元素的属性</h5><ol><li>order<br> 默认为零,按源代码的顺序排列元素,强制添加数字则可以排序<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/order.svg" alt="csst"></li><li>flex-grow<br> 设置分配比例,默认为1,平均分配||更换为2则改元素是其他元素的两倍(负值不可用)<br> <img src="https://css-tricks.com/wp-content/uploads/2018/10/flex-grow.svg" alt="csst"></li><li>flex-shrink<br> 设置缩小比例,与grow类似</li><li>flex-basis<br> 设置默认的获得扩充空间的比例,元素本身+其他空间,这里的其他空间会被分配给元素,和grow相关,添加grow的比例就会分配空间<br> <img src="https://www.w3.org/TR/css-flexbox-1/images/rel-vs-abs-flex.svg" alt="w3c"></li><li>flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]   简写</li><li>align-self<br> 对单个元素的对齐方式进行规定,用于覆盖align-items<br> 不支持float,clear,vertical-align</li></ol></li></ul><ul><li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">完全使用手册和案例–来自css-tricks</a></li><li><a href="https://css-tricks.com/using-flexbox/">新旧flex一些差异[旧]</a></li></ul><h3 id="Gird-网格"><a href="#Gird-网格" class="headerlink" title="Gird 网格"></a>Gird 网格</h3><ul><li><a href="https://css-tricks.com/snippets/css/complete-guide-grid/">待整理</a></li></ul><h3 id="none-隐藏"><a href="#none-隐藏" class="headerlink" title="none 隐藏"></a>none 隐藏</h3><ul><li>值得注意的是,隐藏后的元素还是存在与DOM中</li></ul><h3 id="table-values-表格"><a href="#table-values-表格" class="headerlink" title="table-values 表格"></a>table-values 表格</h3><ul><li>与标签table的功能类似,但是不同的是有更多的语义表达</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<span class="hljs-comment">/*&lt;table&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-cell;<span class="hljs-comment">/*&lt;td&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-column;<span class="hljs-comment">/* &lt;col&gt; */</span><br>  <span class="hljs-attribute">display</span>: table-colgroup;<span class="hljs-comment">/* &lt;colgroup&gt; */</span><br>  <span class="hljs-attribute">display</span>: table-header-group;<span class="hljs-comment">/*&lt;thead&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-row-group;<span class="hljs-comment">/*&lt;tbody&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-footer-group;<span class="hljs-comment">/*&lt;tfoot&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-row;<span class="hljs-comment">/*&lt;tr&gt;*/</span><br>  <span class="hljs-attribute">display</span>: table-caption;<span class="hljs-comment">/*&lt;caption&gt;*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用方式模仿表格</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;div style=&quot;display: table;&quot;&gt;<br>  &lt;div style=&quot;display: table-row;&quot;&gt;<br>    &lt;div style=&quot;display: table-cell;&quot;&gt;<br>     It&#x27;s suck!wubu labu dabuda!<br>    &lt;/<span class="hljs-selector-tag">div</span>&gt;<br>  &lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端手札</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新山鬼</title>
    <link href="/2020/02/09/%E6%96%B0%E5%B1%B1%E9%AC%BC/"/>
    <url>/2020/02/09/%E6%96%B0%E5%B1%B1%E9%AC%BC/</url>
    
    <content type="html"><![CDATA[<p>​    南方的小村以南横亘着一条河，一直往北绵延潜伏在一座山里。山里有座古刹，传说是夏禹治水建造，曰：”山鬼庙“，为众人祈福，保风护雨。千百年来，当地风调雨顺，因而庙宇备受人们敬仰，香火鼎盛。<br>但不料乾坤不定，天灾来临，大水如猛禽掠食，缺粮，死人，饥荒肆虐，哀鸿遍野。<br>​    众人散去，庙宇冷清，僧侣还俗，门可罗雀。<br>​    只留下一位俊俏的小僧，立半柱清香于佛前，守净庭而闲扫落叶，于堂前诵读般若，或打禅静坐，日复一日。<br>常有嫠妇前来添油，不至于小僧多日无餐。但此般妇人多是觊觎小僧貌美，盼其还俗，作家中劳力。她们觉得，似乎在很早以前庙里就一直有一位年轻俊俏的小和尚，但也说不出眼前这位有何异样。<br>小僧只是默而不语，收下香火，道阿弥，赠与瑶草。<br>​    庭前半亩见方之地植有瑶草，盖小僧灾后所植，遗人治病。朝出而作，夕落而服，凡数年，不见小僧色老。<br>​    一日，旦为朝云，暮为行雨。子夜，狂风大作，小僧于佛前击昏惰。有一女子夺门，身披薄裳，腰束女萝，发梢蜷蜷，全身湿透，赤足，肤白，貌美。<br>​    “小施主可否借宿一宿？”女子小声问到。<br>​    小僧不语，击昏惰。<br>​    “公子？”女子来到堂前。<br>​    小僧不语，击昏惰。<br>​    那女子与小僧相对而坐，彻夜无言，直至天明。<br>​    小僧放下木槌，起身出去。<br>​    旦起朝云，僧人落泪：<br>​    “姐姐为何耽误小君修行？”<br>​    说罢，便化云而去。再看那庙中，已无女子，庭前瑶草尽数枯萎。<br>​    日后风雨平顺，众人归来，却再无人问津山中古庙。游人踏青，问：“闻山中有灵庙，此为何山何庙？”<br>其中人语云：“巫山，山鬼庙”。</p><h6 id="作者注：此文灵感来自屈原《楚辞·九歌》及《水经注》先秦神话仙女瑶姬。人物有山鬼（女子），云中君（小僧）。两者皆为风雨之神。本问切入主题描绘青年男女的爱感情心理，结合个人经历想法而作。寓意，人人皆为修行，彼此在风雨之中各有相容，各有距离，相遇便是一场风雨，相识相知便是相对而坐，而耽搁修行便是无言对坐的感慨。千人千面，任君解读"><a href="#作者注：此文灵感来自屈原《楚辞·九歌》及《水经注》先秦神话仙女瑶姬。人物有山鬼（女子），云中君（小僧）。两者皆为风雨之神。本问切入主题描绘青年男女的爱感情心理，结合个人经历想法而作。寓意，人人皆为修行，彼此在风雨之中各有相容，各有距离，相遇便是一场风雨，相识相知便是相对而坐，而耽搁修行便是无言对坐的感慨。千人千面，任君解读" class="headerlink" title="作者注：此文灵感来自屈原《楚辞·九歌》及《水经注》先秦神话仙女瑶姬。人物有山鬼（女子），云中君（小僧）。两者皆为风雨之神。本问切入主题描绘青年男女的爱感情心理，结合个人经历想法而作。寓意，人人皆为修行，彼此在风雨之中各有相容，各有距离，相遇便是一场风雨，相识相知便是相对而坐，而耽搁修行便是无言对坐的感慨。千人千面，任君解读"></a>作者注：此文灵感来自屈原《楚辞·九歌》及《水经注》先秦神话仙女瑶姬。人物有山鬼（女子），云中君（小僧）。两者皆为风雨之神。本问切入主题描绘青年男女的爱感情心理，结合个人经历想法而作。寓意，人人皆为修行，彼此在风雨之中各有相容，各有距离，相遇便是一场风雨，相识相知便是相对而坐，而耽搁修行便是无言对坐的感慨。千人千面，任君解读</h6><p>ps: 本文获冰心青少年文学奖大学组一等奖. 🎉🎉🎉</p><p>作者: 博主本人</p>]]></content>
    
    
    <categories>
      
      <category>南城六月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
